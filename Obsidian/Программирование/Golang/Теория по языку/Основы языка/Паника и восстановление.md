---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Основы_языка_Golang
---
# **`panic` и `recover` в Go**

## **1. Основы паники**

**Что такое panic?**  
Паника — это механизм аварийного завершения программы при критических ошибках. Аналог исключений в других языках, но без механизма `try/catch`.

**Когда возникает:**
- Обращение к `nil` указателю
- Выход за границы массива/слайса
- Явный вызов `panic()`
- Deadlock горутин

```go
func riskyOperation() {
    var s *string
    fmt.Println(*s) // panic: nil pointer dereference
}
```

**Особенности:**
- Останавливает текущую горутину
- Выполняются все отложенные функции (`defer`)
- Если паника не обработана — крашит всю программу

---

## **2. Обработка паники с `recover`**

**Как работает `recover`:**  
Специальная функция, которая останавливает панику и возвращает значение, переданное в `panic()`. Работает только внутри `defer`.

```go
func safeCall() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Программа восстановлена:", r)
        }
    }()
    
    panic("критическая ошибка")
}
```

**Правила использования:**
1. `recover` работает только в `defer`
2. Возвращает `nil`, если нет активной паники
3. Восстанавливает только текущую горутину

---

## **3. Практические примеры**

### **Пример 1: Защита горутин**
```go
func worker() {
    defer func() {
        if r := recover(); r != nil {
            log.Println("Горутина упала, но программа жива:", r)
        }
    }()
    
    // Код, который может паниковать
    panic("ошибка в горутине")
}

func main() {
    go worker()
    time.Sleep(1 * time.Second)
    fmt.Println("Программа продолжает работу")
}
```

### **Пример 2: Безопасный парсинг**
```go
func safeParseJSON(data string) (result map[string]interface{}, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("ошибка парсинга: %v", r)
        }
    }()
    
    result = make(map[string]interface{})
    json.Unmarshal([]byte(data), &result) // Может паниковать при невалидном JSON
    return
}
```

### **Пример 3: Валидация аргументов**
```go
func divide(a, b int) int {
    if b == 0 {
        panic("деление на ноль")
    }
    return a / b
}

func safeDivide(a, b int) (res int, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("%v", r)
        }
    }()
    res = divide(a, b)
    return
}
```

---

## **4. Лучшие практики**

### **Когда использовать `panic`:**
- **Критические ошибки** (потеря соединения с БД, невалидная конфигурация)
- **Ошибки программиста** (неверные аргументы, нарушение контрактов)
- **Тесты** (удобно для проверки ошибок)

### **Когда НЕ использовать:**
- **Ожидаемые ошибки** (файл не найден, неверный ввод пользователя) — используйте `error`
- **Потоковые операции** (HTTP-запросы, фоновые задачи) — обрабатывайте через `error`

### **Правила обработки:**
1. Всегда проверяйте `recover()` в `defer`
2. Логируйте паники для диагностики
3. Восстанавливайте только там, где это безопасно

```go
func main() {
    defer func() {
        if r := recover(); r != nil {
            log.Println("Паника перехвачена:", r)
            // Можно попытаться сохранить данные или отправить уведомление
        }
    }()
    
    startApplication() // Главная логика
}
```

---

## **5. Связь с другими концепциями**

### **1. `defer`**
`recover` работает только внутри `defer` — это ключевая связка для обработки паники.

```go
func handlePanic() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered:", r)
        }
    }()
    panic("test")
}
```

### **2. Горутины**
Каждая горутина обрабатывает панику независимо. Без `recover` упавшая горутина завершит всю программу.

```go
func safeGoRoutine() {
    go func() {
        defer func() {
            if r := recover(); r != nil {
                log.Println("Горутина упала:", r)
            }
        }()
        panic("в горутине")
    }()
}
```

### **3. Тестирование**
В тестах `panic` часто используют для проверки ошибок:

```go
func TestDivision(t *testing.T) {
    assert.Panics(t, func() {
        divide(1, 0)
    })
}
```

---

## **Заключение**
`panic` и `recover` — мощные инструменты для обработки критических ошибок, но требуют аккуратного использования. Основные правила:
- **Паника — для неожиданных ошибок**
- **`recover` — только в `defer`**
- **Всегда логируйте паники**
- **Восстанавливайте только там, где это безопасно**  

Подробнее: [[error, Обработка ошибок]], [[Горутины]].