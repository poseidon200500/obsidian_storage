---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Основы_языка_Golang
Связанные темы:
  - "[[Функции]]"
---
---

# `defer` в Go

**Назначение**  
Ключевое слово `defer` откладывает выполнение функции до момента завершения окружающей функции. Используется для:  
- Очистки ресурсов (файлы, сетевые соединения)  
- Упрощения работы с мьютексами  
- Централизованной обработки ошибок  

Подробнее: [[Управление ресурсами в Go]], [[error, Обработка ошибок]].

---

## Базовые принципы
1. **Порядок выполнения**: LIFO (последний defer выполняется первым).  
2. **Аргументы вычисляются немедленно**, но вызов откладывается.  
3. **Работает даже при панике**.  

```go
func readFile() {
    file, _ := os.Open("data.txt")
    defer file.Close() // Гарантированное закрытие
    
    // Работа с файлом
}
```

---

## Практические примеры

### 1. Очистка ресурсов
```go
func processDB() error {
    db, err := connectDB()
    if err != nil {
        return err
    }
    defer db.Close() // Всегда закрываем соединение

    // ...логика работы с БД...
}
```

### 2. Измерение времени выполнения
```go
func longOperation() {
    defer func(start time.Time) {
        fmt.Printf("Operation took: %v\n", time.Since(start))
    }(time.Now()) // Аргументы вычисляются здесь!

    // ...длительная операция...
}
```

### 3. Безопасная работа с мьютексами
```go
var mu sync.Mutex

func safeUpdate() {
    mu.Lock()
    defer mu.Unlock() // Разблокировка после всех return
    
    // ...критическая секция...
}
```

Подробнее: [[Мьютексы в Go]].

---

## Особенности поведения

### 1. Возвращаемые значения и defer
```go
func counter() (count int) {
    defer func() { count++ }() // Изменяем именованный результат
    return 1 // Фактически вернёт 2
}
```

### 2. Обработка паники
```go
func safeCall() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered:", r)
        }
    }()
    
    panic("что-то пошло не так")
}
```

Подробнее: [[Паника и восстановление]].

---

## Лучшие практики
1. **Избегайте циклов в defer** — будет выполнена только последняя итерация.  
2. **Не используйте для высоконагруженных операций** — накладные расходы.  
3. **Именуйте возвращаемые значения** для модификации в defer.  

**Плохо**:  
```go
defer fmt.Fclose(file) // Если file == nil, будет паника
```  

**Хорошо**:  
```go
if file != nil {
    defer file.Close()
}
```

---

## Связи с другими концепциями

### Работа с горутинами
**Связь**: `defer` гарантирует выполнение финализаций даже при аварийном завершении горутины.  
**Пример**:  
```go
func processData(data chan []byte) {
    defer fmt.Println("Горутина завершена") // Выполнится при любом сценарии
    defer recoverFromPanic()                // Обработка паник
    
    for chunk := range data {
        if len(chunk) == 0 {
            panic("empty chunk")           // defer сработает и здесь
        }
        // обработка данных...
    }
}

func recoverFromPanic() {
    if r := recover(); r != nil {
        log.Printf("Recovered: %v", r)
    }
}
```

---

### Ключевые принципы интеграции:
1. **Ресурсы**: Всегда используйте `defer` для `Close()`, `Release()`, `Unlock()`
2. **Отложенная логика**: Логирование, метрики, уведомления
3. **Безопасность**: Обработка паник в горутинах через `defer recover()`
