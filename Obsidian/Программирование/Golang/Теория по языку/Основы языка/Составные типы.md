---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Основы_языка_Golang
  - Начало
Связанные темы: []
---


# **Составные типы данных в Go**
---
### **На этой странице кратко описан каждый тип, для более подробной информации читайте ссылки ниже**:
- [[Статические массивы]]
- [[Срезы]]
- [[Мапы]]
- [[Структуры]]
- [[Строки]]


---
## **1. Массивы (`[n]T`)**
**Характеристики:**
- Фиксированный размер (определяется при объявлении)
- Однородный тип элементов
- Значимый тип (передаются по значению)

**Основные операции:**
Базовый синтаксис:
```go

//Инициализация:
var days [7]string = [7]string{"пн", "вт", "ср", "чт", "пт", "сб", "вс"}

//Автоматический подсчет размера:
numbers := [...]int{1, 2, 3} // [3]int

//Обращение к элементам:
days[0] = "Понедельник"
fmt.Println(days[1]) // "вт"

//Длина массива:
length := len(days) // 7
```

**Особенности:**
- Размер — часть типа данных (`[3]int` ≠ `[5]int`)
- Неэффективно передавать в функции (создается копия)
- Редко используются напрямую (чаще через слайсы)

---

## **2. Слайсы (`[]T`)**
**Характеристики:**
- Динамические последовательности
- Ссылочный тип (под капотом — указатель на массив)
- Состоят из:
  - Указателя на массив (`ptr`)
  - Длины (`len`)
  - Емкости (`cap`)

**Базовые операции:**
```go
//Создание:
var s1 []int               // nil-слайс
s2 := make([]int, 3, 5)    // длина 3, емкость 5
s3 := []int{1, 2, 3}       // инициализация значениями

//Добавление элементов:
s3 = append(s3, 4)       // [1 2 3 4]
s3 = append(s3, 5, 6, 7) // [1 2 3 4 5 6 7]

//Срезы (slicing):
sub := s3[1:4]           // [2 3 4] (len=3, cap=6)
```
**Критические функции:**
- `len(s)` — текущее количество элементов
- `cap(s)` — максимальная емкость без реаллокации
- `append(s, ...)` — добавление элементов (с автоматическим расширением)

**Важные нюансы:**
```go
//Пример реаллокации:
nums := make([]int, 0, 3) // len=0, cap=3
nums = append(nums, 1)    // cap остается 3
nums = append(nums, 2, 3, 4) // cap увеличивается (обычно x2)
```
---

## **3. Мапы (`map[K]V`)**
**Характеристики:**
- Хеш-таблицы (неупорядоченные коллекции)
- Ключи должны быть сравниваемыми типами
- Нулевое значение — `nil`

**Базовые операции:**
```go
//Инициализация:
ages := map[string]int{
    "Алиса": 25,
    "Боб":   30,
}

//Создание через make:
ratings := make(map[string]float64, 10) // начальная емкость 10

//Добавление/изменение:
ages["Чарли"] = 28

//Проверка существования:
age, exists := ages["Дейв"] // exists=false

//Удаление:
delete(ages, "Боб")
```
**Паттерны работы:**
```go
//Итерация (порядок не гарантирован!):
for name, age := range ages {
    fmt.Printf("%s: %d лет\n", name, age)
}

//Проверка наличия (идиоматический способ):
if age, ok := ages["Алиса"]; ok {
    // ключ существует
}
```
---

## **4. Структуры (`struct`)**
**Характеристики:**
- Композитные типы (собирают разные значения вместе)
- Поля могут быть любого типа
- Поддерживают теги (метаданные)

**Базовый синтаксис:**
```go
//Объявление:
type Person struct {
    Name    string
    Age     int
    Address struct {
        City    string
        Country string
    }
}

//Инициализация:
p1 := Person{Name: "Алиса", Age: 25}
p2 := Person{"Боб", 30, struct{City string; Country string}{"Москва", "РФ"}}

//Обращение к полям:
p1.Age = 26
city := p2.Address.City
```
**Теги структур:**
```go
type User struct {
    ID       int    `json:"id" db:"user_id"`
    Username string `json:"name" validate:"required"`
}

//Использование тегов (пример с encoding/json):
data, _ := json.Marshal(User{1, "alice"})
// {"id":1,"name":"alice"}
```
**Особенности:**
- Сравниваемы, если все поля сравниваемы
- Могут содержать вложенные структуры
- Передаются по значению (используйте указатели для изменений)

---

### **5. Строки (`string`)**
**Характеристики:**
- Неизменяемые последовательности байт
- Поддерживают Unicode (кодировка UTF-8)
- Нулевое значение — пустая строка `""`

**Базовые операции:**
```go
// Инициализация:
s1 := "Привет, мир!"
s2 := `Сырая строка\n (не обрабатывает escape-последовательности)`

// Конкатенация:
greeting := "Hello" + " " + "World"

// Длина строки:
length := len("Привет") // 12 байт (не символов!)

// Доступ к байтам:
firstByte := s1[0] // Получаем byte (uint8)

// Преобразование:
bytes := []byte(s1) // Строка -> байты
str := string(bytes) // Байты -> строка
```

**Важные особенности:**
```go
// Итерация по символам (рунам):
for idx, runeValue := range "Привет" {
    fmt.Printf("%#U starts at byte position %d\n", runeValue, idx)
}

// Сравнение строк:
if "abc" == "abc" { // true (лексикографическое сравнение)
    // ...
}

// Подстроки:
sub := s1[7:10] // Байтовая операция (не символьная)
```

**Критические функции:**
- `strings` пакет: `Contains`, `Split`, `Join`, `Replace` и др.
- `strconv` пакет: преобразования в/из строки
- `utf8` пакет: работа с рунами

**Нюансы:**
- Строки в Go — **неизменяемы** (любая модификация создает новую строку)
- Индексация возвращает **байты**, а не символы (для Unicode используйте `range`)
- Для частых модификаций используйте `strings.Builder`

**Пример эффективной конкатенации:**
```go
var builder strings.Builder
builder.WriteString("Hello")
builder.WriteString(" ")
builder.WriteString("World")
result := builder.String() // "Hello World"
```



---

## **Сравнительная таблица**

| Тип        | Изменяемость | Передача  | Нулевое значение | Особенности              |
|------------|--------------|-----------|------------------|--------------------------|
| Массив     | Да           | По значению | `[n]T{}`        | Фиксированный размер     |
| Слайс      | Да           | По ссылке   | `nil`           | Динамическое расширение  |
| Мапа       | Да           | По ссылке   | `nil`           | Неупорядоченная          |
| Структура  | Поля         | По значению | `T{}`           | Сравниваемость           |
| Строка     | Нет          | По значению | `""`            | UTF-8, неизменяемость    |

--- 

Также обновите раздел "Рекомендации по использованию", добавив пункт про строки:
5. **[[Строки]]** — для текстовых данных (используйте `strings` пакет для операций)