---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Основы_языка_Golang
Связанные темы:
---

# **Выделение памяти в Go**  

---

## **1. `new()` vs `make()`**  

### **`new()`**  
- **Что делает**:  
  - Выделяет память под **нулевое значение** типа  
  - Возвращает **[[Указатели|указатель]]** (`*T`)  

- **Когда использовать**:  
  - Для структур, базовых типов (`int`, `float64` и т.д.)  
  - Когда нужен указатель на заранее неизвестные данные  

- **Пример**:  
  ```go
  ptr := new(int)  // *int с значением 0
  s := new([]int) // *[]int (nil-слайс)
  ```

### **`make()`**  
- **Что делает**:  
  - Выделяет память и **инициализирует** сложные типы:  
    - Слайсы (`[]T`)  
    - Мапы (`map[K]V`)  
    - Каналы (`chan T`)  
  - Возвращает **значение** (не указатель!)  

- **Когда использовать**:  
  - Для готовых к использованию коллекций  
  - При необходимости указать ёмкость/размер  

- **Пример**:  
  ```go
  slice := make([]int, 5)  // Слайс из 5 нулей
  m := make(map[string]int, 10) // Мап с начальной ёмкостью 10
  ch := make(chan bool, 3)     // Буферизованный канал
  ```

### **Сравнение**  
| Особенность       | `new()`               | `make()`                |  
|-------------------|-----------------------|-------------------------|  
| Возвращаемый тип  | `*T`                  | `T`                     |  
| Инициализация     | Нулевое значение      | Готовая коллекция       |  
| Применимость      | Любые типы            | Только slice/map/chan   |  

---

## **2. Стек vs Куча**  

### **Стек**  
- **Что хранится**:  
  - Локальные переменные функций  
  - Аргументы вызовов  
  - Указатели на объекты в куче  

- **Особенности**:  
  - Автоматическое управление (очистка при выходе из функции)  
  - Быстрый доступ (∼1-10 ns)  
  - Ограниченный размер (∼1-8 MB на горутину)  

- **Пример**:  
  ```go
  func foo() {
      x := 42  // Выделено на стеке
      y := new(int) // Указатель на стеке, значение в куче
  }
  ```

### **Куча**  
- **Что хранится**:  
  - Данные с **неизвестным временем жизни**  
  - Общие ресурсы между горутинами  
  - Крупные объекты (>10 KB)  

- **Особенности**:  
  - Управляется **сборщиком мусора** (GC)  
  - Медленнее стека (∼100 ns на доступ)  
  - Динамический размер (ограничен ОС)  

- **Пример**:  
  ```go
  func createBigData() *BigStruct {
      data := BigStruct{} // Может уйти в кучу (если "убегает")
      return &data
  }
  ```

### **Escape Analysis**  
Компилятор Go решает, где размещать объекты:  
```go
func bar() *int {
    x := 42 
    return &x // x "убегает" в кучу
}
```
Проверить решения компилятора:  
```bash
go build -gcflags="-m" main.go
# Вывод: "moved to heap: x"
```

---

## **3. Практические советы**  

### **Как уменьшить аллокации в куче?**  
1. Используйте **sync.Pool** для временных объектов  
2. Избегайте **указателей** в структурах, если возможно  
3. Задавайте **ёмкость** для слайсов/мап через `make`  

### **Когда что выбирать?**  
- **`new()`**:  
  - Редко нужен (лучше использовать литералы `&T{}`)  
  - Только если требуется указатель на нулевое значение  

- **`make()`**:  
  - Всегда для slice/map/chan  
  - Указывайте размер/ёмкость при известных требованиях  

---

**Дополнительно**:  
- [Официальная документация](https://go.dev/doc/effective_go#allocation_new)  
- [Escape Analysis в Go](https://medium.com/a-journey-with-go/go-introduction-to-the-escape-analysis-f7610174e890)  

---

Файл готов для интеграции в Obsidian. Для углубления:  
- `memory/stack_growth.md` (как растёт стек горутины)  
- `memory/arena.md` (экспериментальные аллокаторы)