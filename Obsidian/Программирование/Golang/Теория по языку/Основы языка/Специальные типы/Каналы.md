---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Продвинутые_темы
  - chan
Связанные темы:
  - "[[Специальные типы]]"
  - "[[Каналы_внутреннее_устройство]]"
---
### **Каналы в Go**  
**Файл:** `channels.md`  
**Теги:** `#golang/конкурентность #каналы #горутины`  

---

## **1. Основные понятия**  
Канал — это **типизированный канал связи** между горутинами, обеспечивающий синхронизацию и передачу данных.  

### **Базовый синтаксис**  
```go
ch := make(chan int)     // Небуферизованный канал
bufCh := make(chan int, 3) // Буферизованный (ёмкость=3)
```

### **Особенности**  
- **Потокобезопасны**: Не требуют дополнительных блокировок  
- **Односторонние**: Могут быть ограничены только на отправку (`chan<-`) или получение (`<-chan`)  
- **Нулевое значение**: `nil` (закрытие/отправка в `nil`-канал вызывает панику)  

---

## **2. Типы каналов**  

### **a) Небуферизованные**  
```go
ch := make(chan int)
```
- **Блокируют** отправку/получение до завершения операции другой горутиной  
- Используются для **точной синхронизации**  

### **b) Буферизованные**  
```go
ch := make(chan string, 2)
```
- Позволяют **накапливать** данные (до ёмкости буфера)  
- Отправка блокируется **только при заполненном буфере**  

### **c) Односторонние**  
```go
func producer(ch chan<- int) {} // Только отправка
func consumer(ch <-chan int) {} // Только получение
```

---

## **3. Операции с каналами**  

### **a) Отправка/получение**  
```go
ch <- 42    // Отправка
val := <-ch // Получение
```

### **b) Закрытие каналов**  
```go
close(ch)
```
- **Только отправитель** должен закрывать канал  
- Приёмник может проверять статус:  
  ```go
  val, ok := <-ch // ok=false если канал закрыт
  ```

### **c) Итерация по каналу**  
```go
for item := range ch {
    fmt.Println(item) // Автоматически останавливается при close(ch)
}
```

---

## **4. Паттерны использования**  

### **a) Worker Pool**  
```go
func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        results <- j * 2
    }
}

// Запуск 3 воркеров
jobs := make(chan int, 10)
results := make(chan int, 10)
for w := 1; w <= 3; w++ {
    go worker(w, jobs, results)
}
```

### **b) Fan-out/Fan-in**  
```go
// Распределение задач (fan-out)
inputCh := make(chan int)
go func() { 
    for i := 0; i < 10; i++ { inputCh <- i }
    close(inputCh)
}()

// Сбор результатов (fan-in)
outputCh := make(chan int)
go func() {
    for n := range inputCh { outputCh <- n * 2 }
    close(outputCh)
}()
```

### **c) Таймауты**  
```go
select {
case res := <-ch:
    fmt.Println(res)
case <-time.After(1 * time.Second):
    fmt.Println("Таймаут")
}
```

---

## **5. Внутреннее устройство**  
Канал реализован как **кольцевой буфер** (`hchan` структура в runtime):  
- **sendq/recvq**: Очереди ожидающих горутин  
- **buf**: Буфер данных (для буферизованных каналов)  
- **lock**: Мьютекс для синхронизации  

```go
type hchan struct {
    qcount   uint           // Количество элементов в буфере
    dataqsiz uint           // Размер буфера
    buf      unsafe.Pointer // Указатель на буфер
    closed   uint32         // Флаг закрытия
    // ... другие поля
}
```

### **Более подробно:**
- [[Каналы_внутреннее_устройство]]
---

## **6. Опасные ситуации**  

### **a) Deadlock**  
```go
ch := make(chan int)
ch <- 42       // Блокировка (нет получателя)
val := <-ch    // Недостижимый код
```

### **b) Утечки горутин**  
```go
go func() {
    for {
        select {
        case <-ctx.Done(): return // Важно: выход по контексту
        case val := <-ch: // ...
        }
    }
}()
```

### **c) Закрытие дважды**  
```go
close(ch)
close(ch) // panic: close of closed channel
```

---


**Дополнительно**:  
- [Официальная документация](https://go.dev/ref/spec#Channel_types)  
- [Effective Go: Каналы](https://go.dev/doc/effective_go#channels)  

---

### **Когда использовать?**  
✔️ Для передачи данных между горутинами  
✔️ Для реализации паттернов (worker pool, pub/sub)  
✔️ Для синхронизации выполнения  

❌ Избегайте сложных каскадов каналов (усложняют отладку)  
❌ Не заменяйте ими простые мьютексы там, где достаточно блокировки  
