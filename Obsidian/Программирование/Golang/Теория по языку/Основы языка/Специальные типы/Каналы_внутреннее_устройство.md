---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Основы_языка_Golang
Связанные темы:
  - "[[Каналы]]"
---

# **Внутреннее устройство каналов в Go**  

---

## **1. Базовая структура (`hchan`)**  
Каналы реализованы как структура `hchan` в runtime Go:  
```go
type hchan struct {
    qcount   uint           // Текущее количество элементов в буфере
    dataqsiz uint           // Размер буфера (для буферизованных каналов)
    buf      unsafe.Pointer // Указатель на кольцевой буфер данных
    elemsize uint16         // Размер одного элемента
    closed   uint32         // Флаг закрытия (0/1)
    elemtype *_type         // Тип элементов канала
    sendx    uint           // Индекс отправки (для буфера)
    recvx    uint           // Индекс получения (для буфера)
    recvq    waitq          // Очередь горутин, ожидающих чтения
    sendq    waitq          // Очередь горутин, ожидающих записи
    lock     mutex          // Мьютекс для синхронизации
}
```

---

## **2. Кольцевой буфер**  
Для буферизованных каналов данные хранятся в **[[Кольцевой буфер]]** (`buf`):  
```
+---+---+---+---+---+
| 0 | 1 | 2 | 3 | 4 | <- Индексы буфера
+---+---+---+---+---+
  ↑       ↑
sendx    recvx
```
- `sendx` и `recvx` перемещаются по модулю `dataqsiz`  
- При переполнении буфера горутины блокируются в `sendq` 

---

## **3. Очереди ожидания**  
### **a) `recvq` и `sendq`**  
Списки горутин, заблокированных из-за:  
- **Пустого канала** (для получателей)  
- **Переполненного буфера** (для отправителей)  

Структура `waitq`:  
```go
type waitq struct {
    first *sudog // Горутина в начале очереди
    last  *sudog // Горутина в конце очереди
}
```
Где `sudog` содержит указатель на горутину и элемент данных.

---

## **4. Механизм работы операций**  

### **a) Отправка (`ch <- x`)**  
1. Захватывается `lock` канала.  
2. Если есть получатель в `recvq`:  
   - Элемент **копируется напрямую** в его стек.  
   - Горутина-получатель разблокируется.  
3. Если буфер не полон:  
   - Данные копируются в `buf[sendx]`.  
   - `sendx = (sendx + 1) % dataqsiz`.  
4. Если буфер полон:  
   - Горутина добавляется в `sendq` и блокируется.  

### **b) Получение (`<-ch`)**  
1. Захватывается `lock` канала.  
2. Если есть отправитель в `sendq`:  
   - Для небуферизованного канала: данные копируются **напрямую**.  
   - Для буферизованного: элемент из `sendq` помещается в буфер.  
3. Если буфер не пуст:  
   - Данные читаются из `buf[recvx]`.  
   - `recvx = (recvx + 1) % dataqsiz`.  
4. Если буфер пуст:  
   - Горутина добавляется в `recvq` и блокируется.  

---

## **5. Закрытие канала (`close(ch)`)**  
1. Устанавливается флаг `closed = 1`.  
2. Все горутины из `recvq` разблокируются и получают нулевые значения.  
3. Все горутины из `sendq` паникуют (`send on closed channel`).  

**Важно**:  
- Закрытие канала **не освобождает** его буфер.  
- Повторное закрытие вызывает панику.  

---

## **6. Производительность**  
### **a) Бенчмарк (nanoseconds/op)**  
| Операция            | Небуферизованный | Буферизованный (size=1) |  
|---------------------|------------------|-------------------------|  
| Отправка+получение  | 120 ns           | 85 ns                   |  

### **b) Потребление памяти**  
- **Небуферизованный**: ~96 байт (базовая `hchan`).  
- **Буферизованный**: `hchan` + `dataqsiz * elemsize`.  

---

## **7. Оптимизации runtime**  
1. **Быстрый путь (fast path)**:  
   - При отсутствии блокировок операции выполняются без перехода в планировщик.  
2. **Lock-free для одиночных операций**:  
   - Атомарные проверки перед захватом `lock`.  

---

## **8. Отладка**  
### **a) Вывод внутреннего состояния**  
```go
func debugChan(ch chan int) {
    c := (*hchan)(unsafe.Pointer(&ch))
    fmt.Printf("qcount=%d, dataqsiz=%d\n", c.qcount, c.dataqsiz)
}
```
**Осторожно**: Используйте `unsafe` только для отладки!

---




**Дополнительно**:  
- [Исходный код `runtime/chan.go`](https://github.com/golang/go/blob/master/src/runtime/chan.go)  
- [Статья "Go Channels under the hood"](https://codeburst.io/go-channels-under-the-hood-1241a5168f38)  

---

### **Когда заглядывать внутрь?**  
✔️ Оптимизация высоконагруженных систем  
✔️ Понимание deadlock-ситуаций  
✔️ Написание низкоуровневых библиотек  

❌ Для повседневного использования достаточно знать внешнее API каналов.  

Файл готов для интеграции в Obsidian. Для углубления:  
- `channels/assembly.md` (разбор ассемблерного кода операций)  
- `channels/race_detector.md` (анализ гонок данных)