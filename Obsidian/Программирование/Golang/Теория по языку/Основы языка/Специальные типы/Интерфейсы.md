---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Основы_языка_Golang
Связанные темы:
Подробнее: "[[Приведение типа(Type assertion)]]"
---
# **Интерфейсы в Go**  

---

## **1. Основная концепция**  
### **Что такое интерфейс?**  
Интерфейс — это **абстрактный тип**, определяющий набор методов, которые должны быть реализованы другими типами. В отличие от многих других языков, в Go интерфейсы реализуются **неявно** — тип автоматически удовлетворяет интерфейсу, если содержит все его методы (утиная типизация: "Если что-то крякает как утка, то это утка").  

### **Ключевые свойства**  
1. **Контракты поведения**:  
   Интерфейсы описывают **что** должен делать тип, но не **как** он это делает.  

2. **Динамическая диспетчеризация**:  
   Вызов метода через интерфейс определяется в runtime.  

3. **Полиморфизм**:  
   Один интерфейс может иметь множество реализаций.  

### **Пример объявления**  
```go
type Writer interface {
    Write(data []byte) (int, error)
}
```  
Любой тип с методом `Write([]byte) (int, error)` автоматически реализует этот интерфейс.  

---

## **2. Пустой интерфейс (`interface{}`)**  
### **Определение**  
Специальный тип интерфейса **без методов**, который может хранить значение любого типа.  

### **Использование**  
```go
var anyValue interface{}  
anyValue = 42               // int  
anyValue = "hello"          // string  
anyValue = []float64{1, 2}  // slice  
```  

### **Type Assertion**  
Проверка и преобразование типа:  
```go
val, ok := anyValue.(string)  
if ok {  
    fmt.Println(val) // "hello"  
}  
```  
#### Подробнее: [[Приведение типа(Type assertion)]]
### **Type Switch**  
```go
switch v := anyValue.(type) {  
case int:  
    fmt.Println("int:", v)  
case string:  
    fmt.Println("string:", v)  
default:  
    fmt.Println("unknown type")  
}  
```  

---

## **3. Практическое применение**  
### **a) Полиморфизм**  
```go
type Saver interface {  
    Save() error  
}  

func Backup(s Saver) {  
    s.Save() // Работает с любым типом, реализующим Saver  
}  
```  

### **b) Тестирование (моки)**  
```go
type Database interface {  
    GetUser(id int) (*User, error)  
}  

type MockDB struct{}  
func (m *MockDB) GetUser(id int) (*User, error) {  
    return &User{ID: id}, nil  
}  
```  

### **c) Обработка разных типов данных**  
```go
func PrintJSON(v interface{}) {  
    jsonData, _ := json.Marshal(v)  
    fmt.Println(string(jsonData))  
}  
```  

---

## **4. Внутреннее устройство**  
Интерфейс в Go — это **динамический контракт**, состоящий из:  
1. **Таблицы методов** (itab) — связывает интерфейс с конкретным типом.  
2. **Указателя на значение** — хранит фактическое данные.  

```go
var w Writer = os.Stdout  
```  
- `itab` связывает `Writer` с `*os.File`  
- Значение указывает на объект `os.Stdout`  

### **Более подробно:**
- [[Интерфейсы_внутреннее_устройство]]

---

## **5. Опасные моменты**  
### **a) Nil-интерфейсы**  
Интерфейс равен `nil` только если **и тип, и значение** равны `nil`:  
```go
var s Speaker // nil-интерфейс  
s.Speak()     // panic!  
```  

### **b) Неправильное приведение типов**  
```go
var data interface{} = "text"  
num := data.(int) // panic: interface conversion  
```  

### **c) Избыточное использование пустых интерфейсов**  
Ухудшает читаемость и безопасность типов.  

---

**Дополнительно**:  
- [Официальная документация](https://go.dev/ref/spec#Interface_types)  
- [Effective Go: Интерфейсы](https://go.dev/doc/effective_go#interfaces)  

---

### **Когда использовать?**  
✔️ Для определения контрактов между компонентами  
✔️ При работе с разными типами, имеющими общее поведение  
✔️ В тестировании для создания моков  

❌ Избегайте пустых интерфейсов без необходимости  
❌ Не заменяйте ими простые структуры данных