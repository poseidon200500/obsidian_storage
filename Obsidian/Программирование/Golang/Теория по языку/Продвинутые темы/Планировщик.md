---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Продвинутые_темы
  - Планировщик
Связанные темы:
---
# **Планировщик Go (Scheduler)**  

---

## **1. Архитектура планировщика**  

### **Модель M:P:G**  
- **M (Machine)** — поток ОС (kernel thread)  
- **P (Processor)** — логический процессор (ограничено `GOMAXPROCS`)  
- **G (Goroutine)** — горутина (легковесный поток)  

**Принцип работы:**  
- Каждый `P` имеет локальную очередь горутин (runqueue)  
- `M` привязывается к `P` для выполнения горутин  
- Если `P` освобождается, он "ворует" задачи у других `P` (work-stealing)  

---

## **2. Work-Stealing алгоритм**  

### **Как работает:**  
1. Каждый `P` выполняет горутины из своей очереди  
2. Если очередь пуста — `P` проверяет глобальную очередь  
3. Если и там пусто — `P` пытается "украсть" половину задач у случайного `P`  

**Преимущества:**  
- Балансировка нагрузки между ядрами CPU  
- Минимизация блокировок  

---

## **3. Обработка блокирующих операций**  

### **Системные вызовы**  
- Блокирующий вызов → `M` освобождает `P`  
- После завершения `M` пытается захватить новый `P`  

### **Сетевые операции**  
- Используется **netpoller** (неблокирующий ввод/вывод)  
- Горутина ставится на паузу, `P` переходит к другим задачам  

---

## **4. Особенности в Go 1.24+**  

### **Улучшения:**  
- Оптимизация работы netpoller  
- Уменьшение contention при work-stealing  
- Лучшая балансировка нагрузки на многоядерных системах  

**Пример кода для анализа:**  
```go
func main() {
    runtime.GOMAXPROCS(4) // Ограничиваем число P
    for i := 0; i < 100; i++ {
        go func() {
            time.Sleep(1 * time.Second)
        }()
    }
    time.Sleep(2 * time.Second)
}
```

---

## **5. Практические выводы**  

### **Что учитывать:**  
1. `GOMAXPROCS` по умолчанию = числу CPU ядер  
2. Долгие вычисления могут "заморозить" планировщик — используйте `runtime.Gosched()`  
3. Блокирующие операции снижают параллелизм  

**Диагностика:**  
```go
// Статистика планировщика
fmt.Println(runtime.NumGoroutine(), "горутин")
fmt.Println(runtime.GOMAXPROCS(0), "логических CPU")
```

---

**Дополнительно:**  
- [Полный гайд по планировщику](https://habr.com/ru/articles/891426/)
- [Официальный блог о планировщике](https://go.dev/blog/scheduler)  
- [Исходный код runtime/proc.go](https://github.com/golang/go/blob/master/src/runtime/proc.go)