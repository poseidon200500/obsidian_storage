---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Продвинутые_темы
  - Горутины
---

---

# **Горутины в Go**

## **1. Основная концепция**
### **Что такое горутина?**
Горутина — это легковесный поток выполнения, управляемый рантаймом Go. В отличие от системных потоков:
- Занимает всего **2 КБ стека** (динамически расширяется)
- Запускается быстрее потоков ОС
- Работает в пространстве пользователя (не требует переключения контекста ядра)

```go
go func() { // Запуск горутины
    fmt.Println("Выполняется в горутине")
}()
```

### **Ключевые свойства**
1. **Мультиплексирование**  
   Тысячи горутин работают на небольшом числе потоков ОС (по умолчанию = количеству CPU ядер).

2. **Кооперативная многозадачность**  
   Горутины добровольно уступают контроль в точках:
   - Канальные операции (`ch <-`, `<-ch`)
   - Системные вызовы
   - Вызовы `runtime.Gosched()`

3. **Дешевое создание**  
   Сравнение:
   - Горутина: ~2 мкс, 2 КБ памяти
   - POSIX-поток: ~100 мкс, 1 МБ памяти

---

## **2. Жизненный цикл**
### **Запуск**
```go
func main() {
    go printNumbers() // Горутина запускается немедленно
    time.Sleep(100 * time.Millisecond) // Ожидание (анти-паттерн!)
}
```

### **Завершение**
- Горутина завершается при:
  - Возврате из функции
  - Панике (если не обработана)
- **Важно:** Завершение main() убивает все горутины.

### **Ожидание завершения**
Правильные подходы:
1. **sync.WaitGroup**
   ```go
   var wg sync.WaitGroup
   wg.Add(1)
   go func() {
       defer wg.Done()
       // работа...
   }()
   wg.Wait()
   ```

2. **Каналы**
   ```go
   done := make(chan struct{})
   go func() {
       // работа...
       close(done)
   }()
   <-done
   ```

---

## **3. Опасные моменты**
### **Общие ресурсы без синхронизации**
```go
var counter int
for i := 0; i < 1000; i++ {
    go func() {
        counter++ // Data race!
    }()
}
```
**Решение:** `sync.Mutex` или атомарные операции.

### **Игнорирование паник**
```go
go func() {
    defer func() {
        if r := recover(); r != nil { // Обязательно!
            log.Println("Recovered:", r)
        }
    }()
    riskyOperation()
}()
```

---

**Дополнительно:**  
- [Официальный блог о планировщике](https://go.dev/doc/scheduler)  
- [Паттерны для горутин](https://github.com/golang/go/wiki/CommonMistakes)  

---

### **Когда использовать?**
✔️ Параллельная обработка независимых задач  
✔️ I/O-bound операции (сеть, БД)  
✔️ Долгоживущие фоновые процессы  

❌ CPU-bound задачи без параллелизма (нужны потоки)  
❌ Критичные к latency системы (GC может вызывать задержки)