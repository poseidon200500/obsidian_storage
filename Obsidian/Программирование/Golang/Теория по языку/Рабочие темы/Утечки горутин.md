---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Продвинутые_темы
Связанные темы:
---
# **Утечки горутин в Go: диагностика и профилактика**

---

## **1. Основные причины утечек**

### **a) Зависшие каналы**
```go
func leak() {
    ch := make(chan int)
    go func() {
        val := <-ch  // Ожидание данных (никогда не придут)
        fmt.Println(val)
    }()
    // Завершаем функцию, не закрывая канал
}
```
**Проблема:** Горутина заблокирована навсегда.

### **b) Блокировки мьютексов**
```go
var mu sync.Mutex
func leak() {
    mu.Lock()
    go func() {
        mu.Lock()  // Deadlock - основная горутина не отпустит мьютекс
        defer mu.Unlock()
    }()
}
```

### **c) Бесконечные циклы без условий выхода**
```go
go func() {
    for {  // Бесконечный цикл
        time.Sleep(time.Second)
    }
}()
```

---

## **2. Инструменты диагностики**

### **a) runtime.NumGoroutine()**
```go
func monitor() {
    for {
        fmt.Println("Горутин:", runtime.NumGoroutine())
        time.Sleep(1 * time.Second)
    }
}
```

### **b) pprof**
```bash
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/goroutine
```
**Что показывает:**
- Точки создания горутин
- Текущий стек вызовов
- Количество "зависших" горутин

### **c) trace**
```go
f, _ := os.Create("trace.out")
trace.Start(f)
defer trace.Stop()
```
Анализ через:
```bash
go tool trace trace.out
```

---

## **3. Паттерны предотвращения**

### **a) Graceful shutdown с context**
```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel()  // При завершении программы

go func() {
    select {
    case <-ctx.Done():  // Получаем сигнал завершения
        return
    case data := <-ch:
        process(data)
    }
}()
```

### **b) Таймауты операций**
```go
select {
case result := <-longOperation():
    fmt.Println(result)
case <-time.After(5 * time.Second):
    fmt.Println("Таймаут операции")
    return
}
```

### **c) Ограниченные пулы воркеров**
```go
type WorkerPool struct {
    tasks chan Task
    wg    sync.WaitGroup
}

func (p *WorkerPool) Start(n int) {
    for i := 0; i < n; i++ {
        p.wg.Add(1)
        go p.worker()
    }
}

func (p *WorkerPool) worker() {
    defer p.wg.Done()
    for task := range p.tasks {  // Автоматически завершится при close(p.tasks)
        process(task)
    }
}
```

---

## **4. Практические примеры**

### **a) Завершение по сигналу OS**
```go
func main() {
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
    
    go backgroundJob()
    
    <-sigChan  // Ждем сигнала завершения
    cleanup()
}
```

### **b) Контролируемый drain каналов**
```go
func drain(ch <-chan int) {
    for {
        select {
        case v, ok := <-ch:
            if !ok { return }  // Канал закрыт
            process(v)
        default:
            return  // Нет данных - выходим
        }
    }
}
```

### **c) Ожидание с таймаутом**
```go
func waitWithTimeout(wg *sync.WaitGroup, timeout time.Duration) bool {
    c := make(chan struct{})
    go func() {
        defer close(c)
        wg.Wait()
    }()
    
    select {
    case <-c:
        return true  // Все завершились
    case <-time.After(timeout):
        return false  // Таймаут
    }
}
```

---

## **5. Полезные инструменты**

1. **goleak**  
   Автоматическое обнаружение утечек в тестах:
   ```go
   defer goleak.VerifyNone(t)
   ```

2. **debug.SetTraceback("all")**  
   Подробная информация о всех горутинах при панике.

3. **net/http/pprof**  
   Встроенный профилировщик для production-кода:
   ```go
   import _ "net/http/pprof"
   ```

---

**Золотое правило:**  
Всегда проектируйте горутины с четким механизмом завершения!  
Используйте `context.Context`, `sync.WaitGroup` и каналы для управления жизненным циклом.