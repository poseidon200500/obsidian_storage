---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Продвинутые_темы
Связанные темы:
---
# **Паттерны конкурентного программирования в Go**

---

## **1. Worker Pool (Пул воркеров)**  
*Ограничение количества одновременно выполняемых задач*

### **Реализация:**
```go
type Task struct {
    ID int
    // Другие поля
}

func worker(id int, tasks <-chan Task, results chan<- Result) {
    for task := range tasks {
        results <- process(task)
    }
}

func main() {
    tasks := make(chan Task, 100)
    results := make(chan Result, 100)
    
    // Создаем пул из 10 воркеров
    for w := 1; w <= 10; w++ {
        go worker(w, tasks, results)
    }
    
    // Отправка задач
    for i := 0; i < 100; i++ {
        tasks <- Task{ID: i}
    }
    close(tasks)
    
    // Получение результатов
    for i := 0; i < 100; i++ {
        <-results
    }
}
```
**Применение:**  
- Ограничение нагрузки на систему  
- Обработка большого количества однотипных задач  

---

## **2. Fan-out/Fan-in**  
*Разделение и объединение потоков данных*

### **Реализация:**
```go
// Fan-out: распределение задач по воркерам
func fanOut(input <-chan int, workers int) []<-chan int {
    outputs := make([]<-chan int, workers)
    for i := 0; i < workers; i++ {
        out := make(chan int)
        go func() {
            defer close(out)
            for n := range input {
                out <- n * 2 // Пример обработки
            }
        }()
        outputs[i] = out
    }
    return outputs
}

// Fan-in: объединение результатов
func fanIn(inputs []<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)
    
    for _, in := range inputs {
        wg.Add(1)
        go func(ch <-chan int) {
            defer wg.Done()
            for n := range ch {
                out <- n
            }
        }(in)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
```
**Применение:**  
- Параллельная обработка данных  
- Агрегация результатов из нескольких источников  

---

## **3. Pipeline (Конвейер)**  
*Последовательная обработка через цепочку этапов*

### **Реализация:**
```go
func stage1(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * 2
        }
    }()
    return out
}

func stage2(in <-chan int) <-chan string {
    out := make(chan string)
    go func() {
        defer close(out)
        for n := range in {
            out <- fmt.Sprintf("Value: %d", n)
        }
    }()
    return out
}

func main() {
    // Создаем входные данные
    input := make(chan int)
    go func() {
        for i := 0; i < 10; i++ {
            input <- i
        }
        close(input)
    }()
    
    // Собираем конвейер
    result := stage2(stage1(input))
    
    // Читаем результаты
    for s := range result {
        fmt.Println(s)
    }
}
```
**Применение:**  
- Поточная обработка данных  
- Разделение сложной логики на этапы  

---

## **4. Pub/Sub (Издатель-Подписчик)**  
*Асинхронная рассылка сообщений*

### **Реализация:**
```go
type PubSub struct {
    mu     sync.RWMutex
    subs   map[string][]chan string
}

func (ps *PubSub) Subscribe(topic string) <-chan string {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    ch := make(chan string, 1)
    ps.subs[topic] = append(ps.subs[topic], ch)
    return ch
}

func (ps *PubSub) Publish(topic string, msg string) {
    ps.mu.RLock()
    defer ps.mu.RUnlock()
    
    for _, ch := range ps.subs[topic] {
        ch <- msg
    }
}

func main() {
    ps := &PubSub{subs: make(map[string][]chan string)}
    
    sub1 := ps.Subscribe("news")
    sub2 := ps.Subscribe("sport")
    
    go func() {
        ps.Publish("news", "Новость 1")
        ps.Publish("sport", "Матч начался")
    }()
    
    fmt.Println(<-sub1) // "Новость 1"
    fmt.Println(<-sub2) // "Матч начался"
}
```
**Применение:**  
- Системы событий  
- Микросервисная архитектура  
- Реализация брокера сообщений  

---

## **5. Дополнительные паттерны**  

### **a) Barrier (Барьер)**  
```go
func barrier(workers ...func()) {
    var wg sync.WaitGroup
    wg.Add(len(workers))
    
    for _, worker := range workers {
        go func(f func()) {
            defer wg.Done()
            f()
        }(worker)
    }
    
    wg.Wait()
}
```

### **b) Future/Promise**  
```go
func asyncTask() <-chan Result {
    ch := make(chan Result, 1)
    go func() {
        ch <- longOperation()
    }()
    return ch
}

// Использование
future := asyncTask()
result := <-future // Блокирующее ожидание
```

### **c) Circuit Breaker**  
```go
type CircuitBreaker struct {
    fails     int
    threshold int
    mu       sync.Mutex
}

func (cb *CircuitBreaker) Execute(f func() error) error {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    if cb.fails >= cb.threshold {
        return errors.New("circuit open")
    }
    
    if err := f(); err != nil {
        cb.fails++
        return err
    }
    
    cb.fails = 0
    return nil
}
```

---

**Критерии выбора паттерна:**  
| Паттерн       | Когда использовать                  | Сложность |
|---------------|------------------------------------|-----------|
| Worker Pool   | Ограниченные ресурсы               | Низкая    |
| Fan-out/in    | Параллельная обработка             | Средняя   |
| Pipeline      | Последовательные этапы обработки   | Низкая    |
| Pub/Sub       | Системы событий                    | Высокая   |
| Barrier       | Синхронизация группы горутин       | Низкая    |