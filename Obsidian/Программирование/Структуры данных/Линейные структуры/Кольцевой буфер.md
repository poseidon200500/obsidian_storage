---
tags:
  - Программирование
  - "#Структуры_данных"
Связанные темы:
  - "[[Каналы_внутреннее_устройство]]"
---
# **Кольцевой буфер (Ring Buffer)**  
---

## **1. Основная концепция**  
Кольцевой буфер — это массив фиксированного размера, работающий по принципу **FIFO** (First-In-First-Out), где начало и конец буфера логически соединены.  

### **Ключевые свойства**  
- Фиксированный размер (не растёт динамически)  
- Операции **O(1)** для вставки/удаления  
- Не требует перемещения элементов при переполнении  

---

## **2. Устройство**  
```go
type RingBuffer struct {
    data  []int // массив данных
    head  int   // индекс записи
    tail  int   // индекс чтения
    count int   // текущее количество элементов
}
```
**Работа указателей**:  
```
head → [A][B][C][ ][ ] ← tail (count=3)
При добавлении D:
head → [A][B][C][D][ ] ← tail (count=4)
При извлечении A:
head → [ ][B][C][D][ ] ← tail (count=3)
```

---

## **3. Где используется**  

### **1. Каналы Go**  
- Буферизованные каналы хранят данные в кольцевом буфере (`hchan.buf`).  
- `sendx` и `recvx` — аналоги `head` и `tail`.  

### **2. Асинхронные очереди**  
- Очереди сообщений в RabbitMQ/Kafka.  
- Буферы ввода/вывода в сетевых протоколах.  

### **3. Аудио/Видео обработка**  
- Буферизация потоковых данных (например, в WebRTC).  

### **4. Реализация планировщиков**  
- Очереди задач в реальном времени (RTOS).  

### **5. Игровые движки**  
- Хранение кадров анимации или событий ввода.  

---

## **4. Реализация на Go**  
```go
func (r *RingBuffer) Push(val int) error {
    if r.count == len(r.data) {
        return errors.New("buffer full")
    }
    r.data[r.head] = val
    r.head = (r.head + 1) % len(r.data)
    r.count++
    return nil
}

func (r *RingBuffer) Pop() (int, error) {
    if r.count == 0 {
        return 0, errors.New("buffer empty")
    }
    val := r.data[r.tail]
    r.tail = (r.tail + 1) % len(r.data)
    r.count--
    return val, nil
}
```

---

## **5. Преимущества и недостатки**  
**✓ Плюсы**:  
- Предсказуемое потребление памяти  
- Быстрые операции вставки/извлечения  
- Идеален для фиксированных рабочих нагрузок  

**✗ Минусы**:  
- Не может расти динамически  
- Потеря данных при переполнении (если не реализована перезапись)  

---

**Дополнительно**:  
- [Ring Buffer на Wikipedia](https://en.wikipedia.org/wiki/Circular_buffer)  

---

Файл готов для интеграции в Obsidian/Zettelkasten. Для углубления:  
- `ring_buffer/optimization.md` (cache-friendly дизайн)  
- `ring_buffer/concurrency.md` (потокобезопасные версии)