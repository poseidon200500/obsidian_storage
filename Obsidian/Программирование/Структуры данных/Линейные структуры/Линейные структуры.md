---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Структуры_данных
Связанные темы:
  - "[[Структуры данных]]"
---

---
### **Линейные структуры**  
Линейные структуры данных — это коллекции элементов, где данные располагаются в последовательном порядке (один за другим). Основные операции: обход, вставка, удаление, поиск. В Go некоторые из них встроены (срезы), другие требуют реализации.  

---

#### **1. Массивы и срезы**  
**Массив** — фиксированная коллекция элементов одного типа.  
**Срез** — "динамический массив" с изменяемой длиной.  

```go
// Пример в Go:
arr := [3]int{1, 2, 3}      // Массив
slice := []int{1, 2, 3}     // Срез
slice = append(slice, 4)    // Расширение
```  
**Применение**: Хранение упорядоченных данных, когда важен быстрый доступ по индексу.  
**См. подробнее**: [Статические массивы в Go](obsidian://open?vault=Obsidian&file=%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%2FGolang%2F%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F%20%D0%BF%D0%BE%20%D1%8F%D0%B7%D1%8B%D0%BA%D1%83%2F%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%2F%D0%A1%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B8%D0%BF%D1%8B%2F%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B), [Срезы в Go](obsidian://open?vault=Obsidian&file=%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%2FGolang%2F%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F%20%D0%BF%D0%BE%20%D1%8F%D0%B7%D1%8B%D0%BA%D1%83%2F%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%2F%D0%A1%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B8%D0%BF%D1%8B%2F%D0%A1%D1%80%D0%B5%D0%B7%D1%8B)  

---

#### **2. Связные списки**  
Цепочка узлов, где каждый элемент хранит данные и ссылку на следующий (или предыдущий) узел.  

```go
// Пример узла в Go:
type Node struct {
    data int
    next *Node
}
```  
**Плюсы**:  
- Гибкость вставки/удаления (O(1) при известном узле).  
**Минусы**:  
- Медленный доступ по индексу (O(n)).  
**См. подробнее**: [[Связные списки]]  

---

#### **3. Стеки**  
Принцип **LIFO** (Last In, First Out). Операции:  
- `Push` (добавить на вершину).  
- `Pop` (удалить с вершины).  

```go
// Реализация на срезе:
stack := []int{}
stack = append(stack, 1)  // Push
top := stack[len(stack)-1] // Peek
stack = stack[:len(stack)-1] // Pop
```  
**Применение**: Отмена операций, парсинг выражений, рекурсия.  
**См. подробнее**: [[Стек в Go]]  

---

#### **4. Очереди**  
Принцип **FIFO** (First In, First Out). Операции:  
- `Enqueue` (добавить в конец).  
- `Dequeue` (удалить из начала).  

```go
// Реализация на срезе (неэффективно!):
queue := []int{}
queue = append(queue, 1)  // Enqueue
first := queue[0]          // Peek
queue = queue[1:]          // Dequeue
```  
**Проблемы**: Dequeue на срезе — O(n) из-за сдвига.  
**Альтернативы**: Кольцевой буфер, список.  
**См. подробнее**: [[Очередь|Очередь в Go]]  

---

### **Когда что использовать?**  
| Структура       | Плюсы                          | Минусы                  |  
|-----------------|-------------------------------|-------------------------|  
| **Срезы**       | Быстрый доступ по индексу (O(1)) | Медленные вставка/удаление в начале (O(n)) |  
| **Списки**      | Быстрые вставка/удаление (O(1)) | Медленный доступ по индексу (O(n)) |  
| **Стеки**       | Простая LIFO-логика            | Ограниченная функциональность |  
| **Очереди**     | Идеальны для FIFO              | Сложная эффективная реализация |  

---
