---
tags:
  - Программирование
  - Структуры_данных
---
### **Деревья**  
*Деревья — это иерархические структуры данных, состоящие из узлов, связанных отношениями «родитель-потомок». Каждое дерево начинается с корневого узла и может ветвиться, образуя сложные структуры. Применяются для эффективного поиска, хранения данных с зависимостями и алгоритмов сортировки.*  

---

#### **1. Бинарные деревья**  
**Бинарное дерево** — структура, где каждый узел имеет не более двух потомков: левого и правого.  

```go
// Пример узла в Go:
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}
```  
**Особенности**:  
- Минимальная высота дерева — `O(log n)`, максимальная — `O(n)` (вырожденный случай).  
- Используется в бинарном поиске, синтаксических деревьях.  

**См. подробнее**: [[Бинарные деревья]]  

---

#### **2. Двоичное дерево поиска (BST)**  
**BST** — частный случай бинарного дерева, где для каждого узла:  
- Все значения в левом поддереве **меньше** значения узла.  
- Все значения в правом поддереве **больше** значения узла.  

```go
// Пример поиска в BST:
func search(root *TreeNode, val int) bool {
    if root == nil {
        return false
    }
    if val < root.Val {
        return search(root.Left, val)
    } else if val > root.Val {
        return search(root.Right, val)
    }
    return true
}
```  
**Проблемы**: Может вырождаться в связный список (если элементы добавляются в отсортированном порядке).  
**Решение**: Балансировка (AVL, красно-черные деревья).  
**См. подробнее**: [[Двоичное дерево поиска]]  

---

#### **3. Кучи (Heap)**  
**Куча** — дерево, где каждый родительский узел удовлетворяет условию:  
- **Min-Heap**: `Родитель <= Потомок`.  
- **Max-Heap**: `Родитель >= Потомок`.  

```go
// Пример Min-Heap в Go (обычно реализуется на массиве):
heap := []int{1, 5, 3, 7, 8} // Упрощенное представление
```  
**Применение**:  
- Приоритетные очереди.  
- Алгоритм сортировки Heapsort.  
**См. подробнее**: [[Кучи (Heap)]]  

---

#### **4. Trie-деревья**  
**Trie** (префиксное дерево) — структура для хранения строк, где каждый узел представляет символ.  

```go
// Пример узла Trie:
type TrieNode struct {
    children map[rune]*TrieNode
    isEnd    bool
}
```  
**Плюсы**:  
- Быстрый поиск по префиксу (O(k), где k — длина строки).  
**Минусы**:  
- Высокое потребление памяти.  
**Применение**: Автодополнение, словари.  
**См. подробнее**: [[Trie-деревья]]  

---

### **Сравнение деревьев**  
| Структура       | Вставка       | Поиск        | Память       | Применение          |  
|-----------------|--------------|--------------|--------------|---------------------|  
| **BST**         | O(n)*        | O(n)*        | O(n)         | Сортированные данные |  
| **AVL-дерево**  | O(log n)     | O(log n)     | O(n)         | Балансированные запросы |  
| **Min-Heap**    | O(log n)     | O(1) (min)   | O(n)         | Приоритетные очереди |  
| **Trie**        | O(k)         | O(k)         | O(k * n)     | Работа со строками   |  

> *В худшем случае (несбалансированное дерево).  


---

### Ключевые идеи:  
1. **Балансировка** критична для эффективности BST (отсюда AVL/красно-черные деревья).  
2. **Кучи** часто реализуют на массивах для экономии памяти.  
3. **Trie** — узкоспециализированная, но незаменимая для строк структура.  

Хотите углубиться в конкретный тип деревьев или добавить примеры на Go?