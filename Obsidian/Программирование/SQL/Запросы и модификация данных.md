---
tags:
  - Программирование
  - SQL
---
### **Запросы и модификация данных в SQL**

---

#### **1. SELECT и фильтрация данных**

**Базовый синтаксис:**
```sql
SELECT [DISTINCT] column1, column2, ...
FROM table_name
[WHERE conditions]
```

**Фильтрация с WHERE:**

1. **Базовые операторы:**
```sql
SELECT * FROM products 
WHERE price > 100 AND stock_quantity < 50;
```

2. **Оператор LIKE:**
```sql
-- Найти имена, начинающиеся на 'A'
SELECT * FROM customers 
WHERE first_name LIKE 'A%';

-- Найти email с доменом '@gmail.com'
SELECT * FROM users 
WHERE email LIKE '%@gmail.com';
```

3. **Оператор IN:**
```sql
SELECT * FROM orders 
WHERE status IN ('completed', 'shipped');
```

**Особенности:**
- `NOT LIKE` для обратного условия
- `%` - любое количество символов
- `_` - один символ

---

#### **2. Сортировка и группировка**

**ORDER BY:**
```sql
SELECT product_name, price 
FROM products
ORDER BY price DESC, product_name ASC;
```

**GROUP BY:**
```sql
SELECT department, COUNT(*) as employee_count
FROM employees
GROUP BY department
HAVING COUNT(*) > 5;
```

**Важно:**
- `HAVING` фильтрует результаты группировки
- `GROUP BY` должен включать все неагрегированные столбцы

---

#### **3. Агрегатные функции**

**Основные функции:**

| Функция | Описание                | Пример                     |
|---------|-------------------------|----------------------------|
| COUNT   | Количество строк        | `COUNT(DISTINCT status)`   |
| SUM     | Сумма значений          | `SUM(revenue)`             |
| AVG     | Среднее значение        | `AVG(rating)`              |
| MIN/MAX | Минимальное/максимальное | `MIN(price), MAX(age)`    |

**Пример комплексного запроса:**
```sql
SELECT 
    category,
    COUNT(*) as product_count,
    AVG(price) as avg_price,
    MAX(rating) as max_rating
FROM products
WHERE in_stock = true
GROUP BY category
HAVING AVG(price) > 50;
```

---

#### **4. Подзапросы**

**Типы подзапросов:**

1. **В WHERE:**
```sql
SELECT * FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

2. **В FROM:**
```sql
SELECT dept.name, emp_count.count
FROM departments dept
JOIN (
    SELECT department_id, COUNT(*) as count
    FROM employees
    GROUP BY department_id
) emp_count ON dept.id = emp_count.department_id;
```

3. **В SELECT:**
```sql
SELECT 
    product_name,
    price,
    (SELECT AVG(price) FROM products) as avg_price
FROM products;
```

---

#### **5. Модификация данных**

**INSERT:**
```sql
-- Простая вставка
INSERT INTO customers (name, email)
VALUES ('Иван Иванов', 'ivan@example.com');

-- Вставка нескольких строк
INSERT INTO products (name, price)
VALUES 
    ('Ноутбук', 999.99),
    ('Телефон', 699.99);
```

**UPDATE:**
```sql
-- Обновление с условием
UPDATE employees
SET salary = salary * 1.1
WHERE performance_rating > 8;

-- Обновление с JOIN
UPDATE orders o
JOIN customers c ON o.customer_id = c.id
SET o.priority = 'high'
WHERE c.vip = true;
```

**DELETE:**
```sql
-- Удаление с условием
DELETE FROM logs
WHERE created_at < '2023-01-01';

-- Каскадное удаление
DELETE FROM categories
WHERE id = 10; -- Удалит связанные товары при ON DELETE CASCADE
```

---

#### **6. UPSERT (обновление при конфликте)**

**MySQL (ON DUPLICATE KEY UPDATE):**
```sql
INSERT INTO users (id, username, email)
VALUES (1, 'ivan', 'ivan@example.com')
ON DUPLICATE KEY UPDATE 
    username = VALUES(username),
    email = VALUES(email);
```

**PostgreSQL (ON CONFLICT DO UPDATE):**
```sql
INSERT INTO products (sku, name, price)
VALUES ('P100', 'Ноутбук', 999)
ON CONFLICT (sku) DO UPDATE SET
    name = EXCLUDED.name,
    price = EXCLUDED.price;
```

**Альтернативы:**
- `REPLACE` (MySQL) - удаляет и вставляет заново
- `MERGE` (стандарт SQL) - поддерживается в PostgreSQL 15+

---

### **Сравнение MySQL и PostgreSQL**

| Операция       | MySQL                          | PostgreSQL                   |
|----------------|--------------------------------|------------------------------|
| UPSERT         | `ON DUPLICATE KEY UPDATE`      | `ON CONFLICT DO UPDATE`      |
| LIMIT/OFFSET   | `LIMIT 10 OFFSET 20`           | `LIMIT 10 OFFSET 20`         |
| Возврат данных | `SELECT ... INTO @variable`    | `RETURNING` clause           |

---

**См. также:**  
- [[Транзакции и ACID]]  
- [[Оптимизация SQL-запросов]]  
- [[Работа с индексами]]  

**Дополнительные материалы:**  
- Подзапросы с EXISTS/NOT EXISTS  
- Оконные функции (PostgreSQL)  
- Временные таблицы в сложных запросах