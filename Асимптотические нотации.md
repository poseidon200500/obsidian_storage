---
tags:
  - Шаблоны
  - Программирование
---
# Асимптотические нотации

*Математические инструменты для описания поведения алгоритма при росте объема входных данных*

## Введение

**Асимптотические нотации** — это математические инструменты для описания предельного поведения функций при стремлении аргумента к бесконечности. В анализе алгоритмов они используются для характеристики времени выполнения или потребления памяти в зависимости от размера входных данных.

## 1. Big O нотация (Верхняя граница)

### Определение
**Big O** описывает верхнюю границу роста функции. Говорим, что f(n) = O(g(n)), если существуют положительные константы c и n₀ такие, что:

```
0 ≤ f(n) ≤ c × g(n) для всех n ≥ n₀
```

### Смысл
"f(n) растет не быстрее, чем g(n)"

### Примеры в Go
```go
// O(1) - Константное время
func getFirstElement(arr []int) int {
    if len(arr) > 0 {
        return arr[0]
    }
    return -1
}

// O(n) - Линейное время
func findElement(arr []int, target int) bool {
    for _, num := range arr {
        if num == target {
            return true
        }
    }
    return false
}

// O(n²) - Квадратичное время  
func findPairs(arr []int) int {
    count := 0
    for i := 0; i < len(arr); i++ {
        for j := i + 1; j < len(arr); j++ {
            if arr[i] == arr[j] {
                count++
            }
        }
    }
    return count
}
```

## 2. Big Ω нотация (Нижняя граница)

### Определение
**Big Omega** описывает нижнюю границу роста функции. f(n) = Ω(g(n)), если существуют положительные константы c и n₀ такие, что:

```
0 ≤ c × g(n) ≤ f(n) для всех n ≥ n₀
```

### Смысл
"f(n) растет не медленнее, чем g(n)"

### Примеры
```go
// Ω(n) - В лучшем случае должны проверить все элементы
func containsValue(arr []int, target int) bool {
    for _, num := range arr {
        if num == target {
            return true
        }
    }
    return false
}

// Ω(n log n) - Сравнительные сортировки
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    // Даже в лучшем случае нужно выполнить O(n log n) операций
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}
```

## 3. Big Θ нотация (Точная оценка)

### Определение
**Big Theta** описывает точную асимптотику функции. f(n) = Θ(g(n)), если f(n) = O(g(n)) и f(n) = Ω(g(n)).

Существуют положительные константы c₁, c₂ и n₀ такие, что:

```
0 ≤ c₁ × g(n) ≤ f(n) ≤ c₂ × g(n) для всех n ≥ n₀
```

### Смысл
"f(n) растет так же, как g(n)"

### Примеры
```go
// Θ(n) - Точная оценка
func sumArray(arr []int) int {
    total := 0
    for _, num := range arr {
        total += num  // Каждый элемент обрабатывается ровно один раз
    }
    return total
}

// Θ(n²) - Точная оценка
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
```

## 4. Практическое применение нотаций

### Анализ вложенных циклов
```go
// O(n × m)
func processMatrix(matrix [][]int) {
    for i := 0; i < len(matrix); i++ {        // O(n)
        for j := 0; j < len(matrix[i]); j++ { // O(m)
            fmt.Print(matrix[i][j], " ")
        }
        fmt.Println()
    }
}

// O(n × k)
func combinations(arr []int, k int) [][]int {
    result := [][]int{}
    // Рекурсивная генерация сочетаний - O(C(n, k))
    var backtrack func(start int, current []int)
    backtrack = func(start int, current []int) {
        if len(current) == k {
            result = append(result, append([]int{}, current...))
            return
        }
        for i := start; i < len(arr); i++ {
            backtrack(i+1, append(current, arr[i]))
        }
    }
    backtrack(0, []int{})
    return result
}
```

### Анализ рекурсивных алгоритмов
```go
// O(2ⁿ) - Экспоненциальное время
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return fibonacci(n-1) + fibonacci(n-2)
}

// O(log n) - Логарифмическое время
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    for left <= right {
        mid := left + (right-left)/2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

## 5. Частые ошибки в определении сложности

### Ошибка 1: Игнорирование констант и младших слагаемых
**Неправильно**: O(2n + 1000)  
**Правильно**: O(n)

```go
// O(n), а не O(2n)
func processTwice(arr []int) {
    for i := 0; i < len(arr); i++ {  // O(n)
        // обработка
    }
    for i := 0; i < len(arr); i++ {  // O(n)
        // обработка
    }
    // Итого: O(n) + O(n) = O(n)
}
```

### Ошибка 2: Неправильный анализ вложенных циклов
**Неправильно**: Всегда O(n²)  
**Правильно**: Зависит от условий

```go
// O(n × m), где m может отличаться от n
func processJaggedArray(arr [][]int) {
    for i := 0; i < len(arr); i++ {          // O(n)
        for j := 0; j < len(arr[i]); j++ {   // O(m_i)
            fmt.Print(arr[i][j])
        }
    }
}
```

### Ошибка 3: Забывание о сложности стандартных операций
```go
func badStringConcat(words []string) string {
    result := ""
    for _, word := range words {          // O(n)
        result += word                    // O(k) где k - длина текущего result
    }
    return result
}
// Кажется O(n), но на самом деле O(n²) из-за копирования строк
```

### Ошибка 4: Путаница между лучшим, средним и худшим случаем
```go
func searchInArray(arr []int, target int) int {
    for i, num := range arr {
        if num == target {
            return i  // Лучший случай: O(1)
        }
    }
    return -1         // Худший случай: O(n)
}
// Правильно говорить: O(n) в худшем случае, O(1) в лучшем
```

## Практические правила анализа

### Основные правила:
1. **Игнорируйте константы**: O(5n) = O(n)
2. **Берите наибольший член**: O(n² + n) = O(n²)
3. **Основание логарифма не важно**: O(log₂n) = O(log n)
4. **Анализируйте худший случай** для Big O

### Распространенные сложности от лучшей к худшей:
```
O(1) < O(log n) < O(√n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)
```

## Заключение

Правильное использование асимптотических нотаций позволяет:
- Сравнивать эффективность алгоритмов
- Предсказывать поведение на больших данных
- Выбирать оптимальные алгоритмы для конкретных задач
- Избегать преждевременной оптимизации

Помните: асимптотический анализ — это инструмент для больших n. На малых объемах данных константы могут играть решающую роль.