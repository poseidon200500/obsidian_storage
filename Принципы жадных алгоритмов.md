---
tags:
  - Программирование
  - Алгоритмы
  - Жадные_алгоритмы
---
# Принципы жадных алгоритмов

*Фундаментальные концепции и условия применимости жадных подходов*

## Определение

**Жадный алгоритм** — это алгоритм, который на каждом шаге принимает локально оптимальное решение в надежде, что конечное решение будет глобально оптимальным. В отличие от динамического программирования, жадные алгоритмы не пересматривают принятые решения.

## Ключевые принципы

### Принцип жадного выбора
Локально оптимальный выбор на каждом шаге должен вести к глобально оптимальному решению. Это означает, что выбранный на текущем шаге элемент должен быть частью оптимального решения.

**Пример**: В задаче о выборе заявок (interval scheduling) мы всегда выбираем заявку с наименьшим временем окончания.

```go
type Interval struct {
    start, end int
}

func scheduleIntervals(intervals []Interval) []Interval {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].end < intervals[j].end
    })
    
    result := []Interval{}
    currentEnd := -1
    
    for _, interval := range intervals {
        if interval.start >= currentEnd {
            result = append(result, interval)
            currentEnd = interval.end
        }
    }
    return result
}
```

### Оптимальная подструктура
Задача должна обладать свойством оптимальной подструктуры — оптимальное решение задачи содержит в себе оптимальные решения подзадач.

**Формальное определение**: Если A — оптимальное решение задачи, и мы делаем жадный выбор x, оставляя подзадачу S, тогда решение A' для S должно быть оптимальным решением этой подзадачи.

### Доказательство корректности

#### Методы доказательства:
1. **Жадный выбор остается в силе**: Показываем, что жадный выбор всегда безопасен
2. **Оптимальная подструктура**: Доказываем, что подзадача обладает теми же свойствами
3. **Индукция**: Используем математическую индукцию для доказательства

**Пример доказательства для задачи о выборе заявок**:
- Пусть A — оптимальное решение
- Пусть первая заявка в A заканчивается в время f
- Если наша жадная стратегия выбрала заявку, заканчивающуюся не позже f, то мы можем заменить первую заявку в A на нашу без ухудшения решения

## Когда жадный подход не работает

### Типичные случаи неудачи:
1. **Задача о рюкзаке 0-1**
   ```go
   // Жадный подход по стоимости/весу не дает оптимальное решение
   items := []struct{ value, weight float64 }{
       {60, 10}, {100, 20}, {120, 30}}
   capacity := 50
   
   // Жадный выбор: {60/10=6, 100/20=5, 120/30=4}
   // Результат: 60 + 100 = 160
   // Оптимум: 100 + 120 = 220
   ```

2. **Задача коммивояжера** — жадный ближайший сосед не дает оптимальный маршрут

3. **Размен монет** для произвольных систем номиналов
   ```go
   // Для номиналов [1, 3, 4] и суммы 6
   // Жадный: 4 + 1 + 1 = 3 монеты
   // Оптимум: 3 + 3 = 2 монеты
   ```

## Сравнение с динамическим программированием

| Аспект | Жадные алгоритмы | Динамическое программирование |
|--------|------------------|-------------------------------|
| **Подход** | Локально оптимальный выбор | Рассматривает все варианты |
| **Память** | O(1) - O(n) | O(n) - O(n²) |
| **Время** | Часто O(n log n) | O(n) - O(2ⁿ) |
| **Доказательство** | Требует строгого доказательства | Более прямолинейно |
| **Применение** | Оптимизационные задачи с определенными свойствами | Задачи с перекрывающимися подзадачами |

## Критерии применимости

Жадный алгоритм likely будет работать, если:
1. Задача обладает свойством жадного выбора
2. Имеет оптимальную подструктуру
3. Можно доказать, что жадный выбор безопасен
4. Локально оптимальные решения ведут к глобальному оптимуму

## Практические рекомендации

1. **Всегда доказывайте корректность** — интуиция может обмануть
2. **Тестируйте на краевых случаях** — особенно когда жадный выбор не очевиден
3. **Сравнивайте с DP решением** — если сомневаетесь в оптимальности
4. **Анализируйте контрпримеры** — ищите случаи, когда жадный подход дает неоптимальный результат

Жадные алгоритмы — мощный инструмент, но требующий тщательного обоснования. Их сила в простоте и эффективности, когда условия применимости выполняются.