---
tags:
  - Шаблоны
  - Программирование
---
# Основные принципы ДП

*Фундаментальные концепции и подходы в динамическом программировании*

## Что такое динамическое программирование?

**Динамическое программирование (ДП)** — это метод решения сложных задач путем разбиения их на более простые подзадачи. Ключевая идея: решить каждую подзадачу только один раз и сохранить результат для последующего использования.

## 1. Оптимальная подструктура

### Определение
Задача обладает **оптимальной подструктурой**, если оптимальное решение задачи может быть получено из оптимальных решений ее подзадач.

### Пример: Числа Фибоначчи
```
F(n) = F(n-1) + F(n-2)
```
Оптимальное решение для F(n) зависит от оптимальных решений для F(n-1) и F(n-2).

### Пример: Кратчайший путь
```go
// Если кратчайший путь из A в C проходит через B,
// то пути A→B и B→C также должны быть кратчайшими
type Graph struct {
    nodes []string
    edges map[string]map[string]int
}

func shortestPathDP(graph Graph, start, end string) int {
    // Используем алгоритм Флойда-Уоршелла
    n := len(graph.nodes)
    dist := make([][]int, n)
    
    for i := range dist {
        dist[i] = make([]int, n)
        for j := range dist[i] {
            if i == j {
                dist[i][j] = 0
            } else {
                dist[i][j] = math.MaxInt32
            }
        }
    }
    
    // Оптимальный путь i→j состоит из оптимальных путей i→k и k→j
    for k := 0; k < n; k++ {
        for i := 0; i < n; i++ {
            for j := 0; j < n; j++ {
                if dist[i][k] + dist[k][j] < dist[i][j] {
                    dist[i][j] = dist[i][k] + dist[k][j]
                }
            }
        }
    }
    
    return dist[nodeIndex[start]][nodeIndex[end]]
}
```

## 2. Перекрывающиеся подзадачи

### Определение
**Перекрывающиеся подзадачи** возникают, когда при рекурсивном решении задачи одни и те же подзадачи вычисляются многократно.

### Пример: Наивный Фибоначчи vs ДП
```go
// Наивный подход - экспоненциальная сложность
func fibNaive(n int) int {
    if n <= 1 {
        return n
    }
    return fibNaive(n-1) + fibNaive(n-2)
    // F(4) вычисляет F(3) и F(2)
    // F(3) вычисляет F(2) и F(1) - F(2) вычисляется дважды!
}

// ДП подход - линейная сложность
func fibDP(n int) int {
    if n <= 1 {
        return n
    }
    dp := make([]int, n+1)
    dp[0], dp[1] = 0, 1
    
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2] // Переиспользуем уже вычисленные значения
    }
    
    return dp[n]
}
```

### Визуализация перекрывающихся подзадач
```
        F(5)
       /     \
    F(4)     F(3)
   /    \    /   \
 F(3)  F(2) F(2) F(1)
/   \
F(2) F(1)
```
F(2) вычисляется 3 раза, F(3) - 2 раза

## 3. Мемоизация vs Табуляция

### Мемоизация (Top-Down)
Рекурсивный подход с сохранением результатов подзадач.

```go
// Мемоизация для Фибоначчи
func fibMemo(n int) int {
    memo := make(map[int]int)
    return fibHelper(n, memo)
}

func fibHelper(n int, memo map[int]int) int {
    if n <= 1 {
        return n
    }
    
    // Проверяем, не вычисляли ли мы уже это значение
    if val, exists := memo[n]; exists {
        return val
    }
    
    // Вычисляем и сохраняем
    memo[n] = fibHelper(n-1, memo) + fibHelper(n-2, memo)
    return memo[n]
}

// Мемоизация для задачи о рюкзаке
func knapsackMemo(weights, values []int, capacity int) int {
    memo := make(map[string]int)
    return knapsackHelper(weights, values, capacity, len(weights)-1, memo)
}

func knapsackHelper(weights, values []int, capacity, index int, memo map[string]int) int {
    if capacity == 0 || index < 0 {
        return 0
    }
    
    key := fmt.Sprintf("%d-%d", capacity, index)
    if val, exists := memo[key]; exists {
        return val
    }
    
    // Не берем текущий элемент
    result := knapsackHelper(weights, values, capacity, index-1, memo)
    
    // Берем текущий элемент, если возможно
    if weights[index] <= capacity {
        take := values[index] + knapsackHelper(weights, values, capacity-weights[index], index-1, memo)
        if take > result {
            result = take
        }
    }
    
    memo[key] = result
    return result
}
```

### Табуляция (Bottom-Up)
Итеративный подход с заполнением таблицы снизу вверх.

```go
// Табуляция для Фибоначчи
func fibTabulation(n int) int {
    if n <= 1 {
        return n
    }
    
    dp := make([]int, n+1)
    dp[0], dp[1] = 0, 1
    
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    
    return dp[n]
}

// Табуляция для задачи о рюкзаке
func knapsackTabulation(weights, values []int, capacity int) int {
    n := len(weights)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    
    for i := 1; i <= n; i++ {
        for w := 0; w <= capacity; w++ {
            // Не берем i-й элемент
            dp[i][w] = dp[i-1][w]
            
            // Берем i-й элемент, если возможно
            if weights[i-1] <= w {
                take := values[i-1] + dp[i-1][w-weights[i-1]]
                if take > dp[i][w] {
                    dp[i][w] = take
                }
            }
        }
    }
    
    return dp[n][capacity]
}
```

### Сравнение подходов

| Аспект | Мемоизация | Табуляция |
|--------|------------|-----------|
| **Подход** | Top-Down | Bottom-Up |
| **Память** | Может быть эффективнее | Всегда заполняет всю таблицу |
| **Скорость** | Вычисляет только нужные подзадачи | Вычисляет все подзадачи |
| **Читаемость** | Более естественный | Более явный |
| **Отладка** | Сложнее | Проще |

## 4. Нисходящий и восходящий подходы

### Нисходящий подход (Top-Down)
```go
// Решение "сверху вниз" - начинаем с основной задачи
func coinChangeTopDown(coins []int, amount int) int {
    memo := make(map[int]int)
    return coinChangeHelper(coins, amount, memo)
}

func coinChangeHelper(coins []int, amount int, memo map[int]int) int {
    if amount == 0 {
        return 0
    }
    if amount < 0 {
        return -1
    }
    
    if val, exists := memo[amount]; exists {
        return val
    }
    
    minCoins := math.MaxInt32
    for _, coin := range coins {
        res := coinChangeHelper(coins, amount-coin, memo)
        if res >= 0 && res < minCoins {
            minCoins = res + 1
        }
    }
    
    if minCoins == math.MaxInt32 {
        memo[amount] = -1
        return -1
    }
    
    memo[amount] = minCoins
    return minCoins
}
```

### Восходящий подход (Bottom-Up)
```go
// Решение "снизу вверх" - начинаем с базовых случаев
func coinChangeBottomUp(coins []int, amount int) int {
    dp := make([]int, amount+1)
    for i := range dp {
        dp[i] = amount + 1 // Инициализируем "бесконечностью"
    }
    dp[0] = 0
    
    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if coin <= i {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    
    if dp[amount] > amount {
        return -1
    }
    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

## 5. Критерии применимости ДП

### Основные критерии:
1. **Оптимальная подструктура** ✓
2. **Перекрывающиеся подзадачи** ✓

### Дополнительные признаки:
3. **Задача оптимизации** (минимум/максимум)
4. **Последовательность решений**
5. **Ограниченные ресурсы** (время, память, бюджет)

### Примеры подходящих задач:
```go
// Подходит для ДП - есть перекрывающиеся подзадачи
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    
    return dp[m][n]
}

// НЕ подходит для ДП - нет перекрывающихся подзадач
func binarySearchDP(arr []int, target int) int {
    // Бинарный поиск не имеет перекрывающихся подзадач
    // Каждый шаг уникален и не повторяется
    left, right := 0, len(arr)-1
    for left <= right {
        mid := left + (right-left)/2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

## Шаблон решения ДП задач

### 6 шагов к решению:
1. **Определить состояние** - что представляет dp[i]?
2. **Определить базовые случаи** - самые простые подзадачи
3. **Определить переходы** - как из меньших состояний получить большие
4. **Определить порядок вычислений** - топологический порядок
5. **Реализовать** - мемоизация или табуляция
6. **Восстановить ответ** (если нужно)

```go
// Пример применения шаблона для задачи о рюкзаке
func knapsackTemplate(weights, values []int, capacity int) int {
    // 1. Состояние: dp[i][w] - максимальная стоимость с первыми i предметами и весом w
    dp := make([][]int, len(weights)+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    
    // 2. Базовые случаи: dp[0][w] = 0 (нет предметов)
    // Уже инициализировано нулями
    
    // 3. Переходы:
    for i := 1; i <= len(weights); i++ {
        for w := 0; w <= capacity; w++ {
            // Не берем i-й предмет
            dp[i][w] = dp[i-1][w]
            
            // Берем i-й предмет, если возможно
            if weights[i-1] <= w {
                dp[i][w] = max(dp[i][w], values[i-1] + dp[i-1][w-weights[i-1]])
            }
        }
    }
    
    // 4. Ответ: dp[n][capacity]
    return dp[len(weights)][capacity]
}
```

## Заключение

Динамическое программирование — мощный инструмент для решения задач оптимизации. Ключевые моменты:

- **Ищите оптимальную подструктуру** - можно ли задачу разбить на подзадачи?
- **Ищите перекрывающиеся подзадачи** - вычисляются ли одни решения многократно?
- **Выбирайте подход** - мемоизация для редких вычислений, табуляция для полного покрытия
- **Начинайте с малого** - определите базовые случаи и стройте от них

Практика решения ДП задач развивает важный навык - умение видеть структуру в сложных проблемах и разбивать их на управляемые части.