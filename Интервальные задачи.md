---
tags:
  - Программирование
  - Алгоритмы
  - Жадные_алгоритмы
---
# Интервальные задачи

*Задачи, связанные с работой с интервалами и временными промежутками*

## Общее понятие интервальных задач

**Интервальные задачи** — класс задач, где работа ведется с промежутками времени, числовыми интервалами или другими упорядоченными отрезками. Основные операции: проверка пересечений, объединение, покрытие и выбор оптимального набора.

## Базовая структура интервала

```go
type Interval struct {
    Start int
    End   int
}

// Вспомогательные методы
func (i Interval) Overlaps(other Interval) bool {
    return i.Start < other.End && other.Start < i.End
}

func (i Interval) Length() int {
    return i.End - i.Start
}
```

## 1. Выбор максимального числа непересекающихся интервалов

**Задача**: Дан набор интервалов, найти максимальное количество непересекающихся интервалов.

### Алгоритм (Жадный подход):
1. Сортируем интервалы по времени окончания
2. Последовательно выбираем интервалы, которые не пересекаются с уже выбранными

```go
func maxNonOverlappingIntervals(intervals []Interval) []Interval {
    if len(intervals) == 0 {
        return nil
    }
    
    // Сортируем по времени окончания
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].End < intervals[j].End
    })
    
    result := []Interval{intervals[0]}
    lastEnd := intervals[0].End
    
    for i := 1; i < len(intervals); i++ {
        if intervals[i].Start >= lastEnd {
            result = append(result, intervals[i])
            lastEnd = intervals[i].End
        }
    }
    
    return result
}

// Альтернатива: возвращает только количество
func maxNonOverlappingCount(intervals []Interval) int {
    if len(intervals) == 0 {
        return 0
    }
    
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].End < intervals[j].End
    })
    
    count := 1
    lastEnd := intervals[0].End
    
    for i := 1; i < len(intervals); i++ {
        if intervals[i].Start >= lastEnd {
            count++
            lastEnd = intervals[i].End
        }
    }
    
    return count
}
```

### Сложность:
- Время: O(n log n) из-за сортировки
- Память: O(1) дополнительной памяти

## 2. Покрытие точек интервалами

**Задача**: Дан набор точек на прямой и длина интервала L. Найти минимальное количество интервалов длины L, чтобы покрыть все точки.

### Алгоритм:
1. Сортируем точки
2. Для каждой непокрытой точки размещаем интервал, начинающийся в этой точке

```go
func minIntervalsToCoverPoints(points []int, L int) int {
    if len(points) == 0 {
        return 0
    }
    
    sort.Ints(points)
    count := 0
    i := 0
    
    for i < len(points) {
        count++
        coverUntil := points[i] + L
        
        // Пропускаем все точки, покрытые текущим интервалом
        for i < len(points) && points[i] <= coverUntil {
            i++
        }
    }
    
    return count
}
```

### Вариант: Интервалы фиксированной позиции
```go
func minFixedIntervals(points []int, intervalLength int) int {
    sort.Ints(points)
    count := 0
    coverUntil := -1
    
    for _, point := range points {
        if point > coverUntil {
            count++
            coverUntil = point + intervalLength
        }
    }
    return count
}
```

## 3. Объединение интервалов

**Задача**: Объединить все пересекающиеся интервалы.

```go
func mergeIntervals(intervals []Interval) []Interval {
    if len(intervals) <= 1 {
        return intervals
    }
    
    // Сортируем по времени начала
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })
    
    merged := []Interval{intervals[0]}
    
    for i := 1; i < len(intervals); i++ {
        last := &merged[len(merged)-1]
        
        if intervals[i].Start <= last.End {
            // Объединяем интервалы
            if intervals[i].End > last.End {
                last.End = intervals[i].End
            }
        } else {
            // Добавляем новый интервал
            merged = append(merged, intervals[i])
        }
    }
    
    return merged
}
```

## 4. Расписание мероприятий

**Задача**: Минимизировать количество залов для проведения всех мероприятий.

### Алгоритм:
1. Создаем события начала и окончания
2. Сортируем все события по времени
3. Отслеживаем количество одновременных мероприятий

```go
type Event struct {
    Time   int
    IsStart bool
}

func minMeetingRooms(intervals []Interval) int {
    events := make([]Event, 0, len(intervals)*2)
    
    for _, interval := range intervals {
        events = append(events, Event{Time: interval.Start, IsStart: true})
        events = append(events, Event{Time: interval.End, IsStart: false})
    }
    
    // Сортируем события: сначала по времени, затем окончания перед началами
    sort.Slice(events, func(i, j int) bool {
        if events[i].Time == events[j].Time {
            // Если время одинаковое, окончания идут первыми
            return !events[i].IsStart && events[j].IsStart
        }
        return events[i].Time < events[j].Time
    })
    
    maxRooms, currentRooms := 0, 0
    
    for _, event := range events {
        if event.IsStart {
            currentRooms++
            if currentRooms > maxRooms {
                maxRooms = currentRooms
            }
        } else {
            currentRooms--
        }
    }
    
    return maxRooms
}
```

## 5. Задачи на временные отрезки

### Поиск свободных промежутков
```go
func findFreeTime(intervals []Interval, dayStart, dayEnd int) []Interval {
    merged := mergeIntervals(intervals)
    free := []Interval{}
    
    current := dayStart
    for _, interval := range merged {
        if current < interval.Start {
            free = append(free, Interval{Start: current, End: interval.Start})
        }
        current = max(current, interval.End)
    }
    
    if current < dayEnd {
        free = append(free, Interval{Start: current, End: dayEnd})
    }
    
    return free
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### Проверка возможности участия во всех мероприятиях
```go
func canAttendAll(intervals []Interval) bool {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })
    
    for i := 1; i < len(intervals); i++ {
        if intervals[i].Start < intervals[i-1].End {
            return false
        }
    }
    return true
}
```

## Общие паттерны решения

1. **Сортировка** — почти всегда первый шаг
2. **Сканирующая прямая** — обработка событий начала/окончания
3. **Жадный выбор** — выбор оптимального интервала на каждом шаге
4. **Два указателя** — для обработки множества интервалов

## Практические советы

- Всегда уточняйте, включены ли границы интервалов
- Обрабатывайте случаи с пустыми наборами
- Тестируйте на интервалах с одинаковым временем начала/окончания
- Проверяйте работу с отрицательными временами, если это допустимо

Интервальные задачи отлично решаются жадными подходами и часто встречаются в реальных приложениях: планировщики, календари, системы бронирования и распределения ресурсов.