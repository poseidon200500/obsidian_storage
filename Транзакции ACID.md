---
tags:
  - Программирование
  - SQL
  - Основы_языка_SQL
Связанные_темы: "[[Транзакции и безопасность]]"
---
# Транзакции ACID в PostgreSQL

## Введение в транзакции

Транзакция — это логическая единица работы с базой данных, которая либо выполняется полностью, либо не выполняется вовсе. В PostgreSQL транзакции обеспечивают надежное и предсказуемое выполнение операций даже в условиях сбоев и конкурентного доступа.

## Команды управления транзакциями

### Базовый жизненный цикл транзакции

```
BEGIN → SQL операции → (COMMIT | ROLLBACK)
```

### BEGIN - начало транзакции

Команда `BEGIN` инициирует новую транзакцию. Все последующие операции будут частью этой транзакции до явного завершения.

```sql
BEGIN;
-- Начало блока транзакции
```

**Особенности:**
- PostgreSQL использует модель "транзакция по умолчанию" - каждая команда выполняется в собственной транзакции, если не объявлен явный блок
- `BEGIN` создает явный блок транзакции
- Альтернативные синтаксисы: `START TRANSACTION`

### COMMIT - подтверждение изменений

```sql
COMMIT;
-- Фиксация всех изменений транзакции
```

**Механизм работы:**
1. Проверка соблюдения всех ограничений (constraints)
2. Запись финального состояния в WAL (Write-Ahead Log)
3. Применение изменений к данным
4. Освобождение блокировок

### ROLLBACK - откат изменений

```sql
ROLLBACK;
-- Отмена всех операций текущей транзакции
```

**Сценарии использования:**
- Ошибки выполнения операций
- Нарушение бизнес-логики
- Явный запрос пользователя
- Таймаут выполнения

## Свойства ACID и их реализация

### Atomicity (Атомарность)

**Принцип**: "Все или ничего" - транзакция выполняется полностью либо полностью откатывается.

**Реализация в PostgreSQL**:
- WAL гарантирует, что либо все изменения записаны, либо ни одного
- При сбое системы используется WAL для восстановления согласованного состояния
- `ROLLBACK` отменяет все изменения транзакции

**Пример нарушения атомарности**:
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- Сбой на этом этапе...
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```
В этом случае PostgreSQL гарантирует, что либо обе операции выполнятся, либо обе откатятся.

### Consistency (Согласованность)

**Принцип**: Транзакция переводит базу из одного согласованного состояния в другое.

**Реализация в PostgreSQL**:
- Проверка ограничений (UNIQUE, NOT NULL, FOREIGN KEY, CHECK)
- Триггеры и бизнес-правила
- Гарантия соблюдения схемы данных

**Механизмы обеспечения**:
- Ограничения проверяются при `COMMIT` (deferred constraints) или сразу
- Каскадные операции обновления/удаления
- Проверка типов данных

### Isolation (Изолированность)

**Принцип**: Параллельные транзакции не влияют друг на друга.

**Реализация в PostgreSQL**:
- Multi-Version Concurrency Control (MVCC)
- Уровни изоляции: Read Committed (по умолчанию), Repeatable Read, Serializable
- Механизм снимков данных (snapshots)

**MVCC принцип работы**:
- Каждая транзакция видит снимок данных на момент своего начала
- Изменения других транзакций не видны до их коммита
- Старые версии строк сохраняются до завершения всех зависимых транзакций

### Durability (Долговечность)

**Принцип**: После подтверждения транзакции изменения сохраняются даже при сбое системы.

**Реализация в PostgreSQL**:
- Write-Ahead Log (WAL)
- Синхронная и асинхронная запись
- Репликация и резервное копирование

## WAL (Write-Ahead Log) и гарантии долговечности

### Архитектура WAL

```
Операции изменения → WAL Buffer → WAL Files → Apply to Data Files
```

### Принцип работы WAL

1. **Логирование изменений**: Перед изменением данных в таблицах, изменения записываются в WAL
2. **Буферизация**: WAL-записи сначала попадают в буфер в shared memory
3. **Сброс на диск**: Периодически или при коммите транзакции WAL сбрасывается на диск
4. **Применение к данным**: Постепенно изменения применяются к основным файлам данных

### Настройки долговечности

```sql
-- Синхронная запись (гарантия долговечности)
synchronous_commit = on

-- Асинхронная запись (лучшая производительность, риск потери данных)
synchronous_commit = off

-- Групповая синхронизация
synchronous_commit = remote_write
```

### Влияние на производительность

- **Синхронный режим**: Высокая надежность, меньшая производительность
- **Асинхронный режим**: Высокая производительность, риск потери последних изменений

## Точки сохранения (SAVEPOINT)

### Концепция точек сохранения

SAVEPOINT позволяют создавать вложенные точки отката внутри транзакции, обеспечивая частичный откат без прерывания всей транзакции.

### Использование SAVEPOINT

```sql
BEGIN;

INSERT INTO table1 VALUES (1);
SAVEPOINT sp1;

INSERT INTO table2 VALUES (2);
-- Ошибка в этой операции...
SAVEPOINT sp2;

INSERT INTO table3 VALUES (3);
-- Откат к точке sp2
ROLLBACK TO SAVEPOINT sp2;

-- Продолжение работы...
INSERT INTO table4 VALUES (4);

COMMIT;
```

### Практические сценарии

**Сложные бизнес-процессы**:
```sql
BEGIN;
-- Этап 1: Подготовка данных
SAVEPOINT preparation;

-- Этап 2: Основная обработка  
SAVEPOINT processing;

-- Этап 3: Финализация
SAVEPOINT finalization;

-- При ошибке на любом этапе - откат к предыдущему SAVEPOINT
```

**Обработка частичных сбоев**:
- Ошибки в некритичных операциях
- Валидация данных с возможностью исправления
- Поэтапная миграция данных

### Ограничения SAVEPOINT

- Действуют только в пределах текущей транзакции
- Не могут быть использованы после `COMMIT` или `ROLLBACK`
- Освобождаются автоматически при переходе к более поздним точкам

## Обработка ошибок в транзакциях

### Типы ошибок и их влияние

**Критические ошибки**:
- Нарушение ограничений (UNIQUE, FOREIGN KEY)
- Ошибки синтаксиса SQL
- Нарушение прав доступа

**Некритические ошибки**:
- Предупреждения (WARNING)
- Информационные сообщения
- Ошибки бизнес-логики

### Стратегии обработки ошибок

**Автоматический откат при ошибках**:
```sql
BEGIN;
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2); -- Ошибка здесь вызывает автоматический ROLLBACK
COMMIT; -- Не достигается
```

**Обработка через исключения (в хранимых процедурах)**:
```sql
CREATE OR REPLACE FUNCTION safe_transfer() RETURNS void AS $$
BEGIN
    BEGIN
        UPDATE accounts SET balance = balance - 100 WHERE id = 1;
        UPDATE accounts SET balance = balance + 100 WHERE id = 2;
    EXCEPTION
        WHEN others THEN
            RAISE NOTICE 'Transaction failed: %', SQLERRM;
            ROLLBACK;
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql;
```

### Мониторинг и отладка

**Диагностика проблемных транзакций**:
```sql
-- Текущие активные транзакции
SELECT * FROM pg_stat_activity WHERE state = 'active';

-- Блокировки
SELECT * FROM pg_locks WHERE granted = false;

-- Долгие транзакции
SELECT * FROM pg_stat_activity 
WHERE state = 'active' AND now() - query_start > interval '5 minutes';
```

## Best Practices

### Проектирование транзакций

1. **Минимизация времени жизни**: Транзакции должны быть максимально короткими
2. **Порядок блокировок**: Всегда получать блокировки в одинаковом порядке
3. **Обработка ошибок**: Предусматривать сценарии отката
4. **Тестирование на изоляцию**: Проверять поведение при параллельном выполнении

### Оптимизация производительности

- Использование подходящего уровня изоляции
- Минимизация количества операций в транзакции
- Правильная настройка WAL и контрольных точек
- Мониторинг длительных транзакций

### Безопасность и надежность

- Регулярное резервное копирование
- Мониторинг репликации
- Тестирование процедур восстановления
- Аудит критичных транзакций

Транзакции ACID являются фундаментальным механизмом обеспечения надежности и согласованности данных в PostgreSQL, делая систему подходящей для критически важных приложений.