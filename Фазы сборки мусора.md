---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Сборщик_мусора
  - GC
Связанные темы:
  - "[[Сборщик мусора]]"
---
# **Фазы сборки мусора в Go**  
*Детальный разбор каждого этапа работы сборщика мусора*  

---

## **Общий цикл сборки мусора**

### **Последовательность фаз GC**
```
Полный цикл сборки мусора:
┌─────────────────┐    ┌──────────────────┐    ┌───────────────┐
│ Mark Termination │ -> │ Concurrent Mark   │ -> │ Sweep Phase    │
│ (STW)           │    │ (параллельная)    │    │ (параллельная) │
└─────────────────┘    └──────────────────┘    └───────────────┘
         ↑                      │                       │
         └──────────────────────┴───────────────────────┘
                 Sweep Termination (STW)
```

Каждая фаза выполняет специфические задачи и имеет различные характеристики по времени выполнения и влиянию на приложение.

---

## **Mark Termination (STW фаза)**

### **Назначение и характеристики**
Короткая пауза "остановки мира" для подготовки к основной фазе маркировки:

**Временные параметры:**
- **Длительность**: 50-500 микросекунд
- **Зависит от**: количества активных горутин и размера глобальных данных
- **Частота**: в начале каждого цикла GC

### **Процессы во время паузы**
```
Действия в Mark Termination:
1. ██████████████████ Остановка всех горутин
2. ██████████████ Установка флагов GC активности
3. ██████████ Сканирование глобальных переменных
4. ███████ Сканирование системных корней
5. ███ Инициализация структур маркировки
6. █ Запуск фоновых маркировщиков
```

### **Критические операции**
- **Согласованное состояние**: гарантия, что все горутины видят одинаковое состояние памяти
- **Корневые объекты**: идентификация всех точек входа в граф объектов (глобальные переменные, системные данные)
- **Активация барьеров**: включение write barriers для отслеживания изменений во время concurrent фазы

### **Влияние на приложение**
```
Типичное поведение приложений:
Веб-серверы:    ███ 50-150μs   (минимальное влияние)
Базы данных:    █████ 100-300μs (заметно при высоких RPS)
Научные вычисления: ███████ 200-500μs (критично для real-time)
```

---

## **Concurrent Mark: Сканирование стеков и куч**

### **Архитектура параллельной маркировки**

```
Структура concurrent маркировки:
┌─────────────────────────────────────────────────────────┐
│                    GC Маркировщики                      │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │ Worker 1    │  │ Worker 2    │  │ Worker N    │      │
│  │ Серые → Чёрные│  │ Серые → Чёрные│  │ Серые → Чёрные│      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
└─────────────────────────────────────────────────────────┘
         ↑                ↑                ↑
┌─────────────────────────────────────────────────────────┐
│                 Очередь серых объектов                  │
│  [ObjA][ObjB][ObjC][ObjD][ObjE][ObjF] ...               │
└─────────────────────────────────────────────────────────┘
         ↑                ↑                ↑
┌─────────────────────────────────────────────────────────┐
│                Работающая программа                     │
│  Создание объектов → Write Barriers → Новые серые      │
└─────────────────────────────────────────────────────────┘
```

### **Процесс маркировки по шагам**

**Шаг 1: Обработка очереди серых объектов**
- Каждый маркировщик берет объект из общей очереди
- Сканирует все поля объекта на наличие указателей
- Обнаруженные белые объекты помечаются как серые и добавляются в очередь

**Шаг 2: Сканирование стеков горутин**
- Выполняется параллельно для всех активных горутин
- Каждый указатель в стеке проверяется и обрабатывается
- Специальные оптимизации для больших стеков

**Шаг 3: Обработка глобальных данных**
- Постоянное сканирование глобальных переменных
- Учет изменений через write barriers


---

## **Mark Assist: Помощь горутин в маркировке**

### **Механизм балансировки нагрузки**

```
Система помощи горутин:
┌─────────────────┐    ┌──────────────────┐    ┌───────────────┐
│ Горутина делает  │ -> │ Вычисление долга  │ -> │ Выполнение     │
│ аллокацию       │    │ по аллокациям    │    │ маркировки    │
└─────────────────┘    └──────────────────┘    └───────────────┘
         ↑                      │                       │
         └──────────────────────┼───────────────────────┘
                                ↓
               [Регулятор GC] ← Feedback loop
```

### **Условия активации помощи**

**Триггеры для mark assist:**
1. **Отставание GC** - маркировщики не успевают за темпом аллокаций
2. **Высокий темп создания объектов** - программа генерирует много мусора
3. **Большой размер аллокаций** - единичные крупные allocation'ы

### **Алгоритм расчета помощи**

```
Формула помощи:
Долг помощи = (Размер аллокации × Коэффициент отставания GC)

Где:
- Размер аллокации: объём памяти, который хочет выделить горутина
- Коэффициент отставания: насколько GC отстаёт от плана (0.0 - 2.0)
```

### **Процесс выполнения помощи**

**Шаг 1: Расчет работы**
- Горутина вычисляет сколько байт нужно отсканировать
- Основано на истории аллокаций и текущем отставании GC

**Шаг 2: Выполнение маркировки**
- Горутина берет объекты из очереди серых
- Сканирует их и добавляет найденные ссылки в очередь
- Работает до "погашения долга"

**Шаг 3: Возврат к работе**
- После выполнения помощи горутина продолжает нормальную работу
- Накопленная статистика используется для будущих решений

### **Балансировка и справедливость**

```
Принципы распределения нагрузки:
┌────────────────┬─────────────────────────────────────────┐
│ Принцип        │ Реализация                              │
├────────────────┼─────────────────────────────────────────┤
│ Пропорциональ- │ Горутины, которые больше аллоцируют,    │
│ ность          │ больше помогают                         │
├────────────────┼─────────────────────────────────────────┤
│ Предотвращение │ Ограничение максимального времени       │
│ голодания      │ помощи за один раз                      │
├────────────────┼─────────────────────────────────────────┤
│ Динамическая   │ Автоматическая регулировка на основе    │
│ адаптация      │ метрик производительности               │
└────────────────┴─────────────────────────────────────────┘
```

---

## **Sweep: Освобождение памяти**

### **Процесс освобождения памяти**

**Типы обрабатываемых областей памяти:**

```
Классификация памяти для sweep:
┌────────────────┬──────────────┬──────────────────────────┐
│ Тип span'а     │ Состояние    │ Действие                 │
├────────────────┼──────────────┼──────────────────────────┤
│ Полностью      │ Все объекты  │ Пометить как свободный   │
│ свободный      │ белые        │ span                     │
├────────────────┼──────────────┼──────────────────────────┤
│ Частично       │ Смесь белых  │ Перестроить free list    │
│ использованный │ и чёрных     │ и обновить битмапы       │
├────────────────┼──────────────┼──────────────────────────┤
│ Полностью      │ Все объекты  │ Сбросить цвет для        │
│ занятый        │ чёрные       │ следующего GC            │
└────────────────┴──────────────┴──────────────────────────┘
```

### **Алгоритм очистки span'а**

**Шаг 1: Анализ состояния**
- Проверка битмапа маркировки для каждого объекта в span'е
- Классификация объектов на белые (удаляемые) и чёрные (живые)

**Шаг 2: Освобождение памяти**
- Белые объекты добавляются в свободные списки соответствующего размера
- Обновление статистики использования span'а

**Шаг 3: Управление span'ами**
- Полностью свободные span'ы возвращаются в кучу для повторного использования
- Частично занятые span'ы остаются в активных списках

### **Оптимизации sweep фазы**

```
Техники оптимизации очистки:
┌──────────────────────┬──────────────────────────────────┐
│ Оптимизация          │ Эффект                           │
├──────────────────────┼──────────────────────────────────┤
│ Ленивое освобождение │ Память освобождается по мере     │
│                      │ необходимости, а не сразу        │
├──────────────────────┼──────────────────────────────────┤
│ Кэширование hot      │ Сохранение часто используемых    │
│ span'ов              │ областей в быстром доступе       │
├──────────────────────┼──────────────────────────────────┤
│ Batch processing     │ Групповое освобождение смежных   │
│                      │ областей памяти                  │
└──────────────────────┴──────────────────────────────────┘
```

---

## **Sweep Termination: Завершение очистки**

### **Финальная синхронизация**

```
Процесс завершения цикла GC:
┌─────────────────────────────────────────────────────────┐
│                    Sweep Termination                    │
└─────────────────────────────────────────────────────────┘
                             │
┌─────────────────────────────────────────────────────────┐
│ 1. █████████████ Остановка всех горутин (краткая STW)   │
│ 2. █████████ Завершение оставшейся работы sweep         │
│ 3. ██████ Сброс флагов и статистики GC                  │
│ 4. ███ Обновление планировщика следующего GC            │
│ 5. █ Возобновление выполнения программы                 │
└─────────────────────────────────────────────────────────┘
```

### **Критические операции завершения**

**Гарантии целостности:**
- Все span'ы должны быть обработаны к моменту завершения
- Статистика памяти должна быть актуальной
- Планировщик следующего GC должен быть корректно настроен

**Оптимизации завершения:**
- Инкрементальное завершение для минимизации STW
- Приоритизация критически важных span'ов
- Параллельная обработка когда возможно

### **Переход к следующему циклу**

```
Подготовка к следующему GC:
• Сброс цветов всех объектов на белый
• Обновление значения GOGC и pacing алгоритма
• Настройка триггеров для следующей сборки
• Очистка внутренних структур GC
```

---

## **Взаимодействие фаз и производительность**

### **Временные характеристики полного цикла**

```
Типичное распределение времени GC:
┌─────────────────────────────────────────────────────────┐
│ Mark Termination:   ███ 0.1%  (50-500μs)               │
│ Concurrent Mark:    ██████████████ 89.9%  (10-500ms)   │
│ Sweep:              ████████ 9.9%   (1-50ms)           │
│ Sweep Termination:  ███ 0.1%  (10-100μs)               │
└─────────────────────────────────────────────────────────┘
```

### **Факторы влияния на производительность**

**Увеличивают длительность GC:**
- Большое количество живых объектов
- Высокий темп аллокаций
- Глубокие графы объектов
- Частые изменения указателей

**Снижают влияние на приложение:**
- Эффективная работа concurrent маркировщиков
- Сбалансированная помощь горутин
- Оптимизированные алгоритмы sweep
- Минимизация STW пауз

Каждая фаза сборки мусора тщательно оптимизирована для обеспечения баланса между низкими задержками и эффективным использованием ресурсов, что делает GC Go одним из самых производительных среди современных языков программирования.