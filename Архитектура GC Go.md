---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Продвинутые_темы
  - Управление_памятью
  - Сборщик_мусора
  - GC
Связанные темы:
  - "[[Сборщик мусора]]"
---
# **Архитектура GC Go**  
*Основные компоненты и принципы работы сборщика мусора*  

---

## **Триколорная маркировка**

### **Теория состояний**
Алгоритм триколорной маркировки делит объекты на три категории во время сборки мусора:

- **Белый** - непосещенный объект, кандидат на удаление
- **Серый** - посещенный объект, но его ссылки еще не проверены  
- **Черный** - полностью обработанный объект, все ссылки проверены

### **Процесс маркировки**
```
Начальное состояние:
[Корень] → [A(белый)] → [B(белый)]
           ↓
          [C(белый)]

Шаг 1 - Корень в серые:
[Корень(серый)] → [A(белый)] → [B(белый)]
                  ↓
                 [C(белый)]

Шаг 2 - Обработка корня:
[Корень(черный)] → [A(серый)] → [B(белый)]
                   ↓
                  [C(серый)]

Шаг 3 - Обработка серых:
[Корень(черный)] → [A(черный)] → [B(серый)]
                   ↓
                  [C(черный)] → [D(белый)]
```

---

## **Concurrent Mark-and-Sweep архитектура**

### **Компоненты системы**
- **Mark Workers** - горутины для параллельной маркировки
- **Sweep Workers** - горутины для очистки памяти  
- **Write Barrier** - механизм отслеживания изменений во время GC
- **GC Controller** - алгоритм pacing для планирования сборок

### **Фазы работы GC**
```
Цикл сборки мусора:
1. Mark Setup (STW)      ───┐
2. Concurrent Mark       │ Время
3. Mark Termination (STW)│ выполнения
4. Concurrent Sweep      ───┘
```

---

## **Write Barriers**

### **Назначение барьеров записи**
Write barriers предотвращают потерю ссылок во время concurrent маркировки. При изменении указателя происходит специальная обработка.

### **Типы барьеров в Go**
- **Insertion Barrier** - при добавлении ссылки
- **Deletion Barrier** - при удалении ссылки

```go
// Упрощенная демонстрация работы барьера
func exampleWriteBarrier() {
    var blackObj, whiteObj *Object
    
    // Во время GC эта операция активирует write barrier
    blackObj.ref = whiteObj  // Барьер помечает whiteObj как серый
    
    // Без барьера: blackObj(черный) → whiteObj(белый) → УДАЛЕНИЕ
    // С барьером:  blackObj(черный) → whiteObj(серый) → СОХРАНЕНИЕ
}
```

---

## **Поколения объектов**

### **Теория поколений**
Хотя Go использует преимущественно один heap, объекты ведут себя по-разному в зависимости от времени жизни:

- **Короткоживущие объекты** - часто аллоцируются и быстро умирают
- **Долгоживущие объекты** - остаются в памяти долгое время
- **Крупные объекты** - особый класс для больших аллокаций

### **Статистика выживания**
```
Распределение времени жизни объектов:
┌─────────────────────────────────────┐
│ 70% объектов живут меньше 1ms      │
│ 20% объектов живут 1ms-1s          │
│ 10% объектов живут дольше 1s       │
└─────────────────────────────────────┘
```

---

## **Pacing алгоритм**

### **Принцип работы**
GC pacing определяет когда запускать следующую сборку мусора на основе:

- **Темп аллокаций** - скорость создания новых объектов
- **Размер heap'а** - текущее использование памяти  
- **Целевой рост** - значение GOGC (по умолчанию 100%)

### **Формула принятия решений**
```
Следующий GC запускается когда:
HeapSize ≥ LastGCHeap × (1 + GOGC/100)

Где:
- HeapSize - текущий размер heap'а
- LastGCHeap - размер heap'а после последней сборки
- GOGC - целевой процент роста (по умолчанию 100%)
```

---

## **Практическая демонстрация**

### **Симуляция работы GC**
```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

type Data struct {
    value int
    next  *Data
}

func simulateGCWorkload() {
    var root *Data
    
    // Фаза активных аллокаций
    for i := 0; i < 100000; i++ {
        newData := &Data{value: i, next: root}
        root = newData
    }
    
    // Принудительный запуск GC для демонстрации
    runtime.GC()
    
    // Измеряем статистику
    var stats runtime.MemStats
    runtime.ReadMemStats(&stats)
    
    fmt.Printf("GC cycles: %d\n", stats.NumGC)
    fmt.Printf("Last GC pause: %v\n", time.Duration(stats.PauseNs[(stats.NumGC+255)%256]))
}
```

### **Наблюдение за фазами GC**
```bash
# Запуск с детальной трассировкой GC
GODEBUG=gctrace=1 go run main.go

# Вывод будет содержать:
gc 1 @0.015s 0%: 0.015+0.5+0.003 ms clock, 0.12+0.3/0.5/0.8+0.024 ms cpu
```
Где:
- `0.015ms` - STW маркировка
- `0.5ms` - concurrent маркировка  
- `0.003ms` - STW завершение

---

## **Go 1.25 (Август 2024) - GC GreenTea**

### **Основное фокус**

**Снижение задержек для heap'ов > 100GB**

### **Технические улучшения**

- **Умное разделение работы** - лучший баланс между горутинами
- **Оптимизация сканирования больших объектов** - инкрементальная обработка
- **Улучшенный контроль задержек** - предсказуемое поведение под нагрузкой

### **Особенности GreenTea**

```go

// Новый алгоритм управления задержками
type GreenTeaController struct {
    latencyTarget   time.Duration  // Целевая задержка
    adaptivePacing  bool           // Адаптивный pacing
    incrementalMark bool           // Инкрементальная маркировка
}

// Для больших heap'ов GC работает более "деликатно"
// с фокусом на стабильность задержек, а не только на throughput
```
### **Результаты GreenTea**

```text

Сравнение задержек для 200GB heap:
┌────────────┬──────────────┬──────────────┐
│ Метрика    │ Go 1.24      │ Go 1.25      │
├────────────┼──────────────┼──────────────┤
│ P99 latency│ 150-200ms    │ 50-80ms      │
│ CPU usage  │ 18%          │ 15%          │
│ STW pausues│ 300-500μs    │ 200-300μs    │
└────────────┴──────────────┴──────────────┘
```