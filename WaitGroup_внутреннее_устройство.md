---
создал заметку: 09-11--2025
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Sync
  - WaitGroup
Связанные темы:
---
# **Внутреннее устройство sync.WaitGroup в Go**

## **1. Базовая структура и принцип работы**

WaitGroup предназначен для ожидания завершения группы горутин. Структура использует атомарные операции для управления счетчиком и семафор для блокировки ожидающей горутины.

```go
// Исходный код из src/sync/waitgroup.go
type WaitGroup struct {
    noCopy noCopy // защита от копирования в compile-time
    
    // 64-битное значение разделено на две 32-битные части:
    // high 32 bits: counter (текущее количество активных задач)
    // low 32 bits:  waiter count (количество ожидающих горутин)
    state1 uint64
    state2 uint32
}
```

**Особенности структуры:**

- **noCopy**: zero-size поле, которое активирует проверку `go vet` против копирования
- **state1**: содержит два 32-битных значения в одном 64-битном поле для атомарных операций
- **state2**: используется для хранения семафора в 32-битных системах

**Разделение состояний в 64-битных системах:**
```
state1 [64 бит]
├── counter [32 бита, старшие] - количество активных задач
└── waiters [32 бита, младшие] - количество ожидающих горутин
```

**В 32-битных системах** используется дополнительное поле state2 для выравнивания.

---

## **2. Алгоритм работы Add()**

Метод `Add()` добавляет дельту к счетчику активных задач. Положительная дельта увеличивает счетчик, отрицательная - уменьшает.

```go
func (wg *WaitGroup) Add(delta int) {
    statep, semap := wg.state() // получаем указатели на состояние и семафор
    
    // Атомарно добавляем дельту к счетчику (старшие 32 бита)
    state := atomic.AddUint64(statep, uint64(delta)<<32)
    
    // Извлекаем обновленные значения счетчика и ожидающих
    v := int32(state >> 32) // counter
    w := uint32(state)      // waiters
    
    if v < 0 {
        panic("sync: negative WaitGroup counter")
    }
    if w != 0 && delta > 0 && v == int32(delta) {
        panic("sync: WaitGroup misuse: Add called concurrently with Wait")
    }
    
    // Если счетчик положительный или нет ожидающих - просто возвращаемся
    if v > 0 || w == 0 {
        return
    }
    
    // Счетчик достиг нуля и есть ожидающие - пора их будить
    if atomic.CompareAndSwapUint64(statep, state, 0) {
        // Пробуждаем все ожидающие горутины
        for ; w != 0; w-- {
            runtime_Semrelease(semap, false, 0)
        }
    }
}
```

**Детальный алгоритм Add():**

1. **Атомарное обновление счетчика**: дельта сдвигается на 32 бита и добавляется к state1
2. **Проверка корректности**:
   - Счетчик не должен становиться отрицательным
   - Нельзя вызывать Add с положительной дельтой одновременно с Wait
3. **Условие пробуждения**: если счетчик достиг нуля и есть ожидающие горутины
4. **Атомарный сброс состояния** с проверкой что состояние не изменилось
5. **Пробуждение всех ожидающих** через циклический вызов runtime_Semrelease

---

## **3. Алгоритм работы Done()**

Метод `Done()` является оберткой вокруг `Add(-1)` и уменьшает счетчик на единицу.

```go
func (wg *WaitGroup) Done() {
    wg.Add(-1)
}
```

**Особенности реализации:**

- **Простая делегация** к методу Add с фиксированной дельтой
- **Идиоматическое использование**: всегда вызывается через `defer wg.Done()`
- **Паника при переполнении**: если счетчик становится отрицательным

---

## **4. Алгоритм работы Wait()**

Метод `Wait()` блокирует текущую горутину до тех пор, пока счетчик не достигнет нуля.

```go
func (wg *WaitGroup) Wait() {
    statep, semap := wg.state()
    
    for {
        state := atomic.LoadUint64(statep)
        v := int32(state >> 32) // counter
        w := uint32(state)      // waiters
        
        // Если счетчик уже нулевой - нечего ждать
        if v == 0 {
            return
        }
        
        // Увеличиваем счетчик ожидающих
        if atomic.CompareAndSwapUint64(statep, state, state+1) {
            // Блокируемся на семафоре до пробуждения
            runtime_Semacquire(semap)
            
            // После пробуждения проверяем что состояние сброшено
            if atomic.LoadUint64(statep) != 0 {
                panic("sync: WaitGroup is reused before previous Wait has returned")
            }
            return
        }
    }
}
```

**Детальный алгоритм Wait():**

1. **Проверка оптимистичного случая**: если счетчик уже нулевой, сразу возвращаемся
2. **Цикл CAS**: пытаемся атомарно увеличить счетчик ожидающих
3. **Блокировка на семафоре**: горутина переходит в состояние ожидания
4. **Проверка при пробуждении**: убеждаемся что WaitGroup не был reused
5. **Защита от гонок**: использование atomic.Load для чтения состояния

---

## **5. Внутренний метод state()**

Вспомогательный метод `state()` возвращает указатели на состояние и семафор с учетом архитектуры.

```go
func (wg *WaitGroup) state() (statep *uint64, semap *uint32) {
    if unsafe.Alignof(wg.state1) == 8 || uintptr(unsafe.Pointer(&wg.state1))%8 == 0 {
        // 64-битное выравнивание
        return &wg.state1, &wg.state2
    } else {
        // 32-битное выравнивание
        state := (*[3]uint32)(unsafe.Pointer(&wg.state1))
        return (*uint64)(unsafe.Pointer(&state[1])), &state[0]
    }
}
```

**Логика определения архитектуры:**

- **64-битные системы**: state1 содержит оба значения, state2 - семафор
- **32-битные системы**: массив из трех uint32, где:
  - state[0] - семафор
  - state[1] и state[2] - объединены в uint64 для состояния

---

## **6. Семафорная система и взаимодействие с планировщиком**

### **Реализация семафоров**

WaitGroup использует runtime-семафоры через функции:

```go
runtime_Semacquire(semap *uint32) // блокировка горутины
runtime_Semrelease(semap *uint32) // пробуждение горутины
```

**Процесс блокировки в Semacquire:**

1. **Проверка быстрого пути**: если семафор уже положительный
2. **Добавление в очередь ожидания**: горутина помещается в FIFO-очередь
3. **Переход в ожидание**: вызов `gopark` для перевода горутины в ожидающее состояние
4. **Вытеснение планировщиком**: CPU освобождается для других горутин

**Процесс пробуждения в Semrelease:**

1. **Увеличение значения семафора**
2. **Извлечение горутины из очереди ожидания**
3. **Помещение в очередь исполнения** через `goready`
4. **Планирование на выполнение** при следующем цикле планировщика

---

## **7. Обработка ошибок и паники**

### **Обнаружение некорректного использования**

WaitGroup активно проверяет следующие ошибки:

1. **Отрицательный счетчик**:
```go
if v < 0 {
    panic("sync: negative WaitGroup counter")
}
```

2. **Конкурентный Add и Wait**:
```go
if w != 0 && delta > 0 && v == int32(delta) {
    panic("sync: WaitGroup misuse: Add called concurrently with Wait")
}
```

3. **Reuse до завершения Wait**:
```go
if atomic.LoadUint64(statep) != 0 {
    panic("sync: WaitGroup is reused before previous Wait has returned")
}
```

### **Типичные сценарии ошибок**

**Случай 1: Больше Done() чем Add()**
```go
var wg sync.WaitGroup
wg.Add(1)
wg.Done()
wg.Done() // panic: negative WaitGroup counter
```

**Случай 2: Конкурентные Add и Wait**
```go
var wg sync.WaitGroup
go func() { wg.Add(1) }()
go func() { wg.Wait() }() // возможная паника
```

**Случай 3: Reuse до возврата из Wait**
```go
var wg sync.WaitGroup
wg.Add(1)
go func() { defer wg.Done() }()
go func() { wg.Wait(); wg.Add(1) }() // паника при reuse
```

---

## **8. Атомарные операции и memory ordering**

### **Используемые атомарные примитивы**

- **atomic.AddUint64**: для атомарного изменения счетчика
- **atomic.LoadUint64**: для безопасного чтения состояния
- **atomic.CompareAndSwapUint64**: для конкурентного обновления

### **Барьеры памяти**

Все атомарные операции в WaitGroup обеспечивают:

- **Sequential consistency**: гарантия порядка операций
- **Visibility**: изменения видны всем горутинам
- **Atomicity**: операции выполняются как единое целое

### **Оптимизация через битовые сдвиги**

Использование битовых сдвигов для работы с двумя 32-битными значениями в одном 64-битном:

```go
// Добавление дельты к счетчику (старшие 32 бита)
atomic.AddUint64(statep, uint64(delta)<<32)

// Извлечение счетчика
v := int32(state >> 32)

// Извлечение ожидающих
w := uint32(state)
```

---

## **9. Производительность и оптимизации**

### **Быстрый путь в Wait()**

При уже нулевом счетчике:
- **1 атомарная операция** LoadUint64
- **0 системных вызовов**
- **Немедленный возврат**

### **Быстрый путь в Add()**

При ненулевом счетчике:
- **1 атомарная операция** AddUint64
- **Проверки условий**
- **Немедленный возврат** без взаимодействия с семафорами

### **Временные характеристики**

| Сценарий | Время (нс) | Атомарные операции |
|----------|------------|-------------------|
| Add (fast) | 5-10 | 1 |
| Done (fast) | 5-10 | 1 |
| Wait (fast) | 3-5 | 1 |
| Wait (slow) | 100-1000+ | 2 + системный вызов |

### **Потребление памяти**

- **Базовая структура**: 12 байт (64-бит) или 16 байт (32-бит)
- **На ожидающую горутину**: ~40 байт в очереди семафора
- **Отсутствие динамических аллокаций** в типичном использовании

---

## **10. Практические примеры и паттерны**

### **Сценарий 1: Базовое использование**
```go
var wg sync.WaitGroup

for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done() // гарантированный вызов при любом выходе
        processTask(id)
    }(i)
}

wg.Wait() // блокировка до завершения всех горутин
fmt.Println("All tasks completed")
```

**Состояния WaitGroup:**
- После Add(1): counter = 1, waiters = 0
- После Done(): counter = 0, проверка условий пробуждения
- В Wait(): увеличение waiters, блокировка на семафоре

### **Сценарий 2: Пакетное добавление задач**
```go
var wg sync.WaitGroup
tasks := []string{"task1", "task2", "task3"}

wg.Add(len(tasks)) // однократное добавление всех задач

for _, task := range tasks {
    go func(t string) {
        defer wg.Done()
        process(t)
    }(task)
}

wg.Wait()
```

**Преимущества пакетного Add():**
- Меньше атомарных операций
- Избегание гонок между Add и Wait
- Более предсказуемое поведение

### **Сценарий 3: Вложенные WaitGroup**
```go
func processBatch(batch []Item) {
    var wg sync.WaitGroup
    wg.Add(len(batch))
    
    for _, item := range batch {
        go func(it Item) {
            defer wg.Done()
            
            // Внутренний WaitGroup для подзадач
            var subWg sync.WaitGroup
            subWg.Add(2)
            
            go func() { defer subWg.Done(); processA(it) }()
            go func() { defer subWg.Done(); processB(it) }()
            
            subWg.Wait() // ожидание подзадач
        }(item)
    }
    
    wg.Wait()
}
```

---

## **11. Сравнение с альтернативными подходами**

### **Каналы vs WaitGroup**
```go
// С каналами
done := make(chan bool, N)
for i := 0; i < N; i++ {
    go func() {
        work()
        done <- true
    }()
}
for i := 0; i < N; i++ { <-done }

// С WaitGroup
var wg sync.WaitGroup
wg.Add(N)
for i := 0; i < N; i++ {
    go func() {
        defer wg.Done()
        work()
    }()
}
wg.Wait()
```

**Преимущества WaitGroup:**
- Меньше аллокаций памяти
- Более эффективные атомарные операции
- Чище и идиоматичнее

### **ErrGroup vs WaitGroup**

ErrGroup расширяет WaitGroup добавлением:
- Обработки ошибок из горутин
- Отмены контекста при первой ошибке
- Ограничения количества одновременных горутин

---

**Ссылки на исходный код:**
- [sync/waitgroup.go](https://github.com/golang/go/blob/master/src/sync/waitgroup.go)
- [runtime/sema.go](https://github.com/golang/go/blob/master/src/runtime/sema.go)
- [internal/race/race.go](https://github.com/golang/go/blob/master/src/internal/race/race.go)