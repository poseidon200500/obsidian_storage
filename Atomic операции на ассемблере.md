---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Ассемблер
  - Atomic
Связанные темы:
---
# Atomic операции на ассемблере в Go

**Реализация атомарных примитивов для различных архитектур процессоров**

## 1. Базовая структура и принцип работы

**Общий принцип**: Атомарные операции обеспечивают неделимое выполнение примитивов в многопоточных сценариях через инструкции процессора с гарантиями памяти. Они являются фундаментом для всех высокоуровневых примитивов синхронизации в Go.

**Архитектурный контекст**: Пакет `runtime/internal/atomic` содержит низкоуровневые реализации для разных CPU архитектур (AMD64, ARM64, MIPS), обеспечивая переносимый интерфейс для runtime системы.

## 2. Детальные алгоритмы работы методов

### CAS (Compare-And-Swap) для AMD64

**Шаг 1**: Подготовка аргументов
- Указатель на память загружается в регистр BX
- Ожидаемое старое значение помещается в AX
- Новое значение загружается в CX
```assembly
MOVQ    ptr+0(FP), BX   // Загрузка указателя в BX
MOVQ    old+8(FP), AX   // Ожидаемое значение в AX  
MOVQ    new+16(FP), CX  // Новое значение в CX
```

**Шаг 2**: Атомарное сравнение-и-обмен
- Инструкция LOCK блокирует кэш-линию для эксклюзивного доступа
- CMPXCHGQ сравнивает значение по адресу BX с AX
- Если значения равны, записывает новое значение из CX
```assembly
LOCK                // Блокировка шины памяти
CMPXCHGQ CX, 0(BX)  // Сравнить [BX] с AX, если равно - записать CX
```


**Шаг 3**: Установка результата
- Флаг равенства (ZF) копируется в возвращаемое значение
- Операция возвращает true если замена произошла успешно
```assembly
SETEQ ret+24(FP)    // Установить флаг результата
RET
```
### Load и Store операции

**Атомарная загрузка на AMD64**:
- Использует обычную MOV инструкцию благодаря сильной memory model x86
- Для 64-битных значений гарантирует атомарность на выровненных адресах

**Атомарное сохранение на ARM64**:
- Использует STLR инструкцию с release semantics
- Гарантирует, что предыдущие операции памяти видны другим процессорам

## 3. Внутренние константы и специальные значения

**Memory Ordering уровни**:
- Sequential Consistency: строгий порядок, все операции видны в одном порядке всем процессорам
- Acquire Semantics: последующие операции не могут быть переупорядочены до текущей загрузки
- Release Semantics: предыдущие операции не могут быть переупорядочены после текущей записи

**Барьеры памяти**:
- MFENCE: полный барьер памяти на x86, предотвращает переупорядочивание операций
- SFENCE: барьер для операций записи, обеспечивает видимость store операций
- LFENCE: барьер для операций чтения, обеспечивает порядок load операций

## 4. Режимы работы и состояния

### Режим LOCK префикса на x86

**Состояние обычной операции**: Инструкция выполняется без гарантий атомарности, возможны race conditions
**Состояние атомарной операции**: LOCK префикс блокирует кэш-линию, обеспечивая эксклюзивный доступ
**Переходы состояний**: Процессор автоматически управляет блокировкой кэш-линии через протокол когерентности MESI

### ARM64 exclusive monitors

**Состояние монитора открыто**: LDXR устанавливает exclusive монитор для адреса
**Состояние эксклюзивного доступа**: STXR проверяет что монитор не сброшен конкурирующим доступом
**Сценарий конкуренции**: При одновременном доступе один из STXR завершится неудачно и потребует повтора

## 5. Взаимодействие с runtime и системными компонентами

### Runtime интеграция

**Write barriers**: Атомарные операции с указателями требуют координации со сборщиком мусора для корректного отслеживания живых объектов
**Планировщик**: Очереди исполнения (runq) используют атомарные операции для lock-free доступа из нескольких потоков
**Состояния горутин**: Переходы между состояниями (_Grunning, _Gwaiting) защищены атомарными операциями

### Системные вызовы

**Atomic как примитив**: Многие системные вызовы и runtime механизмы строятся на атомарных операциях

**Memory ordering**: Атомарные операции обеспечивают правильную видимость изменений между горутинами на разных ядрах процессора

---

## 6. Оптимизации производительности

### Быстрый путь vs Медленный путь

**Быстрый путь** - однократное успешное выполнение CAS:
```assembly
// AMD64 быстрая версия Cas64
LOCK CMPXCHGQ CX, 0(BX)  // Одна инструкция для успешного случая
SETEQ ret+24(FP)
RET
```

**Медленный путь** - цикл повторения при конкуренции (ARM64):
```go
// Псевдокод алгоритма LL/SC
for {
    old := LDXR(ptr)        // Load-Linked
    if old != expected {
        return false
    }
    if STXR(ptr, new) {     // Store-Conditional  
        return true         // Успех
    }
    // Повторить при конкуренции
}
```

### Адаптивные алгоритмы

**Backoff стратегии**: При частых коллизиях CAS добавляется экспоненциальная задержка между попытками

**Spin count ограничение**: После N неудачных попыток переходить к блокирующим операциям

## 7. Обработка ошибок и паники

### Проверки корректности состояния

```go
// runtime/atomic.go - проверки валидности
func atomiccheck() {
    if !isAtomicAlignment(uintptr(unsafe.Pointer(ptr))) {
        throw("unaligned atomic operation")
    }
}
```

**Типичные ошибки**:
- Невыровненные адреса для 64-битных операций
- Обращение к nil указателям
- Использование на неподдерживаемой архитектуре

### Восстановление консистентности

**Гарантии атомарности**: Даже при панике в конкурирующей горутине, память не остается в поврежденном состоянии

**Memory barrier гарантии**: Операции завершаются либо полностью, либо не выполняются вовсе

## 8. Атомарные операции и memory model

### Используемые примитивы

```assembly
// AMD64 основные примитивы
LOCK ADD/Q  // Атомарное сложение
LOCK OR/Q   // Атомарное ИЛИ  
LOCK AND/Q  // Атомарное И
LOCK XCHG/Q // Атомарный обмен
LOCK CMPXCHG/Q // Сравнение-и-обмен
```

### Гарантии памяти

**x86-TSO модель**: Обеспечивает полную упорядоченность операций записи

**ARM/POWER weak memory model**: Требует явных барьеров для упорядочивания

```go
// Go memory model гарантии через атомарные операции
var data int
var flag uint32

// Producer
data = 42
atomic.StoreUint32(&flag, 1) // Release semantics

// Consumer  
if atomic.LoadUint32(&flag) == 1 { // Acquire semantics
    fmt.Println(data) // Гарантированно увидит 42
}
```

## 9. Производительность и характеристики

**Таблица производительности** (циклы процессора):

| Операция | AMD64 | ARM64 | Заметки |
|----------|-------|-------|---------|
| CAS 64-bit | 15-25 | 20-40 | Зависит от конкуренции |
| Load 64-bit | 1-3 | 2-5 | Почти как обычная загрузка |
| Store 64-bit | 3-5 | 5-10 | Release semantics |
| Add 64-bit | 10-20 | 15-30 | Атомарное сложение |

**Scalability**: Атомарные операции хорошо масштабируются при низкой конкуренции, но деградируют при высокой

## 10. Практические примеры работы

### Сценарий 1: Lock-free счетчик

```go
type Counter struct {
    value int64
}

func (c *Counter) Increment() {
    atomic.AddInt64(&c.value, 1)
}

func (c *Counter) Value() int64 {
    return atomic.LoadInt64(&c.value)
}
```

**Состояния памяти**:
- Инициализация: value = 0
- После Increment(): value атомарно увеличивается на 1
- Value() всегда видит консистентное значение

### Сценарий 2: Spinlock реализация

```go
type Spinlock struct {
    state uint32
}

func (s *Spinlock) Lock() {
    for !atomic.CompareAndSwapUint32(&s.state, 0, 1) {
        // Exponential backoff или PAUSE инструкция
        runtime.Gosched()
    }
}

func (s *Spinlock) Unlock() {
    atomic.StoreUint32(&s.state, 0)
}
```

### Сценарий 3: Singleton с двойной проверкой

```go
var (
    instance *Service
    initialized uint32
)

func GetInstance() *Service {
    if atomic.LoadUint32(&initialized) == 0 {
        lock.Lock()
        defer lock.Unlock()
        if atomic.LoadUint32(&initialized) == 0 {
            instance = &Service{}
            atomic.StoreUint32(&initialized, 1) // Release semantics
        }
    }
    return instance
}
```

## 11. Сравнительный анализ

### Альтернатива 1: Мьютексы vs Атомики

**Производительность**: Атомики быстрее в низкоконкурентных сценариях
**Сложность**: Атомики требуют аккуратного проектирования lock-free алгоритмов
**Применимость**: Мьютексы проще для сложных инвариантов

### Альтернатива 2: Каналы vs Атомарные счетчики

**Использование памяти**: Атомики используют меньше памяти
**Expressiveness**: Каналы проще для координации сложных workflows

## 12. Ссылки на исходный код

- **[AMD64 реализации](https://github.com/golang/go/blob/master/src/runtime/internal/atomic/atomic_amd64.s)**
- **[ARM64 реализации](https://github.com/golang/go/blob/master/src/runtime/internal/atomic/atomic_arm64.s)**
- **[Atomic тесты](https://github.com/golang/go/blob/master/src/runtime/internal/atomic/atomic_test.go)**
- **[Go Memory Model](https://go.dev/ref/mem)**

---
