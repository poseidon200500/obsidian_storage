---
tags:
  - Шаблоны
  - Программирование
  - Теория_по_языку_Golang
Связанные темы:
---
# Уровни изоляции транзакций в PostgreSQL

## 1. Стандартные уровни изоляции ANSI SQL

### Модель аномалий параллельного доступа

Уровни изоляции определяются через запрещенные аномалии:

| Уровень изоляции | Dirty Read | Non-repeatable Read | Phantom Read | Serialization Anomaly |
|------------------|------------|---------------------|--------------|----------------------|
| Read Uncommitted | Разрешен   | Разрешен           | Разрешен     | Разрешен            |
| Read Committed   | **Запрещен** | Разрешен           | Разрешен     | Разрешен            |
| Repeatable Read  | **Запрещен** | **Запрещен**       | **Запрещен** | Разрешен            |
| Serializable     | **Запрещен** | **Запрещен**       | **Запрещен** | **Запрещен**        |

**Особенность PostgreSQL**: Read Uncommitted работает как Read Committed - "грязное" чтение невозможно.

## 2. Read Committed - поведение по умолчанию

### Механизм работы

**Snapshot на уровне оператора**:
- Каждый оператор SELECT видит снимок данных на момент своего начала
- Операции UPDATE/DELETE видят последние закоммиченные данные

```sql
-- Транзакция A
BEGIN; -- Уровень изоляции Read Committed по умолчанию
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- Транзакция B (параллельная)
BEGIN;
SELECT balance FROM accounts WHERE id = 1; 
-- Видит старую версию, так как транзакция A не завершена

-- Транзакция A
COMMIT;

-- Транзакция B
SELECT balance FROM accounts WHERE id = 1; 
-- Теперь видит новые данные от транзакции A
COMMIT;
```

### Типичные сценарии

**Non-repeatable read**:
```sql
-- Транзакция 1
BEGIN;
SELECT balance FROM accounts WHERE id = 1; -- Возвращает 1000

-- Транзакция 2 (параллельно)
BEGIN;
UPDATE accounts SET balance = 900 WHERE id = 1;
COMMIT;

-- Транзакция 1
SELECT balance FROM accounts WHERE id = 1; -- Возвращает 900!
COMMIT;
-- Получили разные значения в одной транзакции
```

**Phantom read**:
```sql
-- Транзакция 1
BEGIN;
SELECT COUNT(*) FROM accounts WHERE balance > 1000; -- Возвращает 5

-- Транзакция 2 (параллельно)
BEGIN;
INSERT INTO accounts (name, balance) VALUES ('New User', 1500);
COMMIT;

-- Транзакция 1
SELECT COUNT(*) FROM accounts WHERE balance > 1000; -- Возвращает 6!
COMMIT;
-- Появилась "фантомная" строка
```

## 3. Repeatable Read и snapshot isolation

### Механизм работы

**Единый snapshot на всю транзакцию**:
- Все операторы видят согласованный снимок данных на момент начала первого оператора
- Гарантирует повторяемость чтений

```sql
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- Снимок данных фиксируется при первом операторе
SELECT balance FROM accounts WHERE id = 1; -- Снимок создан

-- Даже если другие транзакции изменят данные,
-- мы продолжаем видеть исходный снимок
SELECT balance FROM accounts WHERE id = 1; -- То же значение

COMMIT;
```

### Обработка конфликтов

**Ошибка сериализации при записи**:
```sql
-- Транзакция 1
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT balance FROM accounts WHERE id = 1; -- balance = 1000

-- Транзакция 2
BEGIN;
UPDATE accounts SET balance = 900 WHERE id = 1;
COMMIT;

-- Транзакция 1
UPDATE accounts SET balance = 1100 WHERE id = 1;
-- ОШИБКА: could not serialize access due to concurrent update
-- Транзакция должна быть перезапущена
```

### Преимущества и ограничения

**Гарантии**:
- Все SELECT видят одинаковые данные в течение транзакции
- Отсутствуют non-repeatable reads и phantom reads
- Предсказуемое поведение для отчетов и аналитических запросов

**Ограничения**:
- Возможны ошибки сериализации при конкурентных записях
- Требует обработки ошибок в приложении
- Может приводить к отказу транзакций

## 4. Serializable - строгая сериализуемость

### Механизм Serializable Snapshot Isolation (SSI)

**Обнаружение конфликтов сериализации**:
- Отслеживание зависимостей "чтение-запись" между транзакциями
- Прерывание транзакций, нарушающих сериализуемость

```sql
-- Транзакция A
BEGIN ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(*) FROM accounts WHERE balance > 1000; -- Читает условие

-- Транзакция B  
BEGIN ISOLATION LEVEL SERIALIZABLE;
UPDATE accounts SET balance = 1500 WHERE id = 3; -- Пишет в зону условия

-- Транзакция A
INSERT INTO audit_log (message) VALUES ('High balance accounts checked');
COMMIT; -- Успешно

-- Транзакция B
COMMIT; -- Может получить ошибку сериализации!
```

### Практическое использование

**Сценарии для Serializable**:
- Финансовые операции с строгими требованиями согласованности
- Системы бронирования и распределения ресурсов
- Сложные бизнес-процессы с множественными зависимостями

```sql
-- Безопасное выполнение в цикле повторных попыток
DO $$
BEGIN
    LOOP
        BEGIN
            -- Критическая операция
            PERFORM transfer_funds(1, 2, 100);
            EXIT; -- Успех
        EXCEPTION 
            WHEN serialization_failure THEN
                -- Повторить попытку
                CONTINUE;
        END;
    END LOOP;
END;
$$;
```

## 5. Аномалии параллельного доступа

### Dirty Read (Грязное чтение)

**Определение**: Чтение незакоммиченных данных из другой транзакции

**В PostgreSQL**: Невозможно на любом уровне изоляции

```sql
-- НЕВОЗМОЖНО в PostgreSQL:
-- Транзакция A
BEGIN;
UPDATE accounts SET balance = 0; -- Не коммитит

-- Транзакция B  
SELECT SUM(balance) FROM accounts; -- Никогда не увидит 0!
```

### Non-repeatable Read (Неповторяемое чтение)

**Определение**: Получение разных значений при повторном чтении одной строки

```sql
-- Read Committed - разрешено
BEGIN; -- Read Committed
SELECT balance FROM accounts WHERE id = 1; -- 1000
-- Другая транзакция меняет баланс на 900 и коммитит
SELECT balance FROM accounts WHERE id = 1; -- 900 ← изменилось!

-- Repeatable Read/Serializable - запрещено  
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT balance FROM accounts WHERE id = 1; -- 1000
-- Другая транзакция меняет баланс на 900 и коммитит
SELECT balance FROM accounts WHERE id = 1; -- 1000 ← то же значение!
```

### Phantom Read (Фантомное чтение)

**Определение**: Появление новых строк между операциями чтения

```sql
-- Read Committed - разрешено
BEGIN;
SELECT COUNT(*) FROM users WHERE active = true; -- 50
-- Другая транзакция добавляет нового активного пользователя
SELECT COUNT(*) FROM users WHERE active = true; -- 51 ← фантом!

-- Repeatable Read/Serializable - запрещено
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT COUNT(*) FROM users WHERE active = true; -- 50
-- Другая транзакция добавляет нового активного пользователя  
SELECT COUNT(*) FROM users WHERE active = true; -- 50 ← без фантомов
```

### Serialization Anomaly (Аномалия сериализации)

**Определение**: Результат параллельного выполнения транзакций невозможно получить при их последовательном выполнении

```sql
-- Классический пример "write skew"
-- Транзакция A: Проверяет условие X, изменяет Y
-- Транзакция B: Проверяет условие Y, изменяет X
-- По отдельности валидны, вместе нарушают инвариант

-- Только уровень Serializable предотвращает эту аномалию
BEGIN ISOLATION LEVEL SERIALIZABLE;
-- Бизнес-логика с проверками и изменениями
COMMIT; -- Может быть прервана при обнаружении аномалии
```

## Сравнительная таблица уровней изоляции

| Критерий | Read Committed | Repeatable Read | Serializable |
|----------|----------------|-----------------|--------------|
| **Производительность** | Высокая | Средняя | Низкая |
| **Конфликты** | Редкие | Возможны | Частые |
| **Гарантии** | Минимальные | Strong snapshot | Полная сериализуемость |
| **Сложность** | Низкая | Средняя | Высокая |
| **Типичное использование** | OLTP, веб-приложения | Отчеты, аналитика | Финансы, бронирования |

## Рекомендации по выбору

**Read Committed**:
- Большинство веб-приложений
- Простые OLTP-операции
- Когда phantom reads/non-repeatable reads приемлемы

**Repeatable Read**:
- Генерация отчетов
- Сложные аналитические запросы
- Когда нужна гарантированная согласованность данных

**Serializable**:
- Критически важные финансовые операции
- Системы распределения ограниченных ресурсов
- Когда бизнес-правила требуют полной сериализуемости