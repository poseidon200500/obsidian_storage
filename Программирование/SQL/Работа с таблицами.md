---
tags:
  - Программирование
  - SQL
  - Основы_языка_SQL
---
### **Работа с таблицами в SQL**

---

#### **1. DDL (Data Definition Language)**

**Основные команды:**

1. **CREATE TABLE**  
```sql
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department VARCHAR(50),
    salary DECIMAL(10,2)
);
```

2. **ALTER TABLE**  
```sql
-- Добавление столбца
ALTER TABLE employees ADD COLUMN hire_date DATE;

-- Изменение типа столбца
ALTER TABLE employees ALTER COLUMN department TYPE VARCHAR(75);

-- Удаление столбца
ALTER TABLE employees DROP COLUMN salary;
```

3. **DROP TABLE**  
```sql
DROP TABLE IF EXISTS temp_employees;
```

**Особенности:**
- В PostgreSQL: поддерживаются транзакции для DDL
- В MySQL: большинство DDL операций не транзакционные

---

#### **2. Ограничения (Constraints)**

**Типы ограничений:**

1. **PRIMARY KEY**  
```sql
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);
```

2. **FOREIGN KEY**  
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    product_id INT REFERENCES products(product_id),
    quantity INT
);
```

3. **UNIQUE**  
```sql
ALTER TABLE employees ADD CONSTRAINT unique_email UNIQUE (email);
```

4. **CHECK**  
```sql
CREATE TABLE students (
    id INT PRIMARY KEY,
    age INT CHECK (age >= 16),
    grade VARCHAR(2) CHECK (grade IN ('A', 'B', 'C', 'D', 'F'))
);
```

**Советы:**
- Именуйте ограничения для удобного управления
- Используйте ON DELETE/UPDATE для каскадных действий

---

#### **3. Индексы**

**Типы индексов:**

| Тип индекса | Поддержка | Лучшее применение |
|-------------|-----------|-------------------|
| B-Tree      | MySQL, PostgreSQL | Основной тип, диапазонные запросы |
| Hash        | PostgreSQL | Точные совпадения (=) |
| GIN         | PostgreSQL | Составные значения (массивы, JSON) |
| GiST        | PostgreSQL | Геоданные, полнотекстовый поиск |
| FULLTEXT    | MySQL      | Текстовый поиск |

**Примеры создания:**

1. **Базовый индекс**  
```sql
CREATE INDEX idx_employee_name ON employees(name);
```

2. **Составной индекс**  
```sql
CREATE INDEX idx_employee_dept_salary ON employees(department, salary);
```

3. **Специальные индексы**  
```sql
-- PostgreSQL GIN индекс для JSON
CREATE INDEX idx_product_tags ON products USING GIN (tags);

-- MySQL FULLTEXT индекс
CREATE FULLTEXT INDEX idx_article_content ON articles(content);
```

**Оптимизация:**
- Анализируйте запросы с EXPLAIN
- Удаляйте неиспользуемые индексы

Подробнее: [[Индексы SQL]]

---

#### **4. Партиционирование таблиц**

Партиционирование данных (или секционирование) – это метод разделения больших таблиц или баз данных на более мелкие, логические части (партиции). Это позволяет улучшить производительность, управляемость и доступность данных, особенно в случае больших объемов информации.

**Типы партиционирования:**

1. **По диапазону (RANGE)**  
```sql
-- PostgreSQL
CREATE TABLE sales (
    id SERIAL,
    sale_date DATE,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (sale_date);

CREATE TABLE sales_2023 PARTITION OF sales
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');
```

2. **По списку (LIST)**  
```sql
-- MySQL
CREATE TABLE employees (
    id INT,
    name VARCHAR(100),
    region VARCHAR(50)
)
PARTITION BY LIST COLUMNS(region) (
    PARTITION p_north VALUES IN ('NY', 'MA', 'PA'),
    PARTITION p_south VALUES IN ('TX', 'FL', 'GA')
);
```

3. **По хешу (HASH)**  
```sql
-- MySQL
CREATE TABLE logs (
    id BIGINT,
    log_data TEXT
)
PARTITION BY HASH(id)
PARTITIONS 4;
```

**Преимущества:**
- Ускорение запросов по условию партиционирования
- Упрощение управления большими таблицами
- Возможность хранить партиции на разных дисках

---

#### **5. Практические примеры**

**Создание оптимизированной таблицы:**
```sql
CREATE TABLE ecommerce.orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date TIMESTAMPTZ DEFAULT NOW(),
    total_amount DECIMAL(12,2) CHECK (total_amount > 0),
    status VARCHAR(20) CHECK (status IN ('new', 'processing', 'shipped', 'completed')),
    CONSTRAINT fk_customer FOREIGN KEY (customer_id) REFERENCES customers(id)
) PARTITION BY RANGE (order_date);

-- Индексы
CREATE INDEX idx_order_customer ON ecommerce.orders(customer_id);
CREATE INDEX idx_order_status_date ON ecommerce.orders(status, order_date);
```

**Миграция существующей таблицы:**
```sql
-- 1. Создаем новую партиционированную таблицу
-- 2. Копируем данные
INSERT INTO orders_partitioned SELECT * FROM orders;
-- 3. Переименовываем таблицы
-- 4. Создаем триггеры для перенаправления запросов
```

---

#### **6. Сравнение MySQL и PostgreSQL**

| Функция            | MySQL                          | PostgreSQL                   |
|--------------------|--------------------------------|------------------------------|
| Партиционирование  | Только табличное               | Табличное и наследование     |
| Индексы            | B-Tree, FULLTEXT               | B-Tree, Hash, GIN, GiST, SP-GiST, BRIN |
| DDL в транзакциях  | Ограниченная поддержка         | Полная поддержка             |
| FOREIGN KEY        | Каскадные действия             | Каскадные + SET NULL/DEFAULT |

---

**См. также:**  
- [[Оптимизация запросов к большим таблицам]]  
- [[Управление транзакциями]]  
- [[Репликация и шардинг]]  

**Дополнительные материалы:**  
- `ANALYZE TABLE` в MySQL
- `VACUUM ANALYZE` в PostgreSQL  
- Системные представления: `information_schema`, `pg_catalog`