---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - "#Sync"
  - "#Mutex"
  - Внутренее_устройство
Связанные темы:
---
# **Внутреннее устройство sync.Mutex в Go**

## **1. Базовая структура и состояния мьютекса**

Мьютекс в Go реализован как сложная структура с несколькими состояниями, оптимизированная для производительности в различных сценариях использования.

```go
// Исходный код из src/sync/mutex.go
type Mutex struct {
    state int32  // содержит состояние мьютекса и количество ожидающих горутин
    sema  uint32 // семафор для блокировки/разблокировки горутин
}
```

**Поле `state` содержит битовую маску с несколькими флагами:**

- **Бит 0 (mutexLocked)**: указывает, заблокирован ли мьютекс (значение 1). Когда этот бит установлен, мьютекс находится во владении какой-либо горутины.

- **Бит 1 (mutexWoken)**: флаг "пробуждения" (значение 2). Устанавливается когда горутина уже была разбужена или находится в процессе spin-ожидания. Этот флаг предотвращает излишнее пробуждение других горутин.

- **Бит 2 (mutexStarving)**: флаг "голодания" (значение 4). Указывает что мьютекс находится в режиме голодания, который активируется когда горутина ждет блокировки более 1 миллисекунды.

- **Биты 3-31**: содержат счетчик ожидающих горутин. Каждое ожидание увеличивает этот счетчик на 8 (значение `mutexWaiterShift`).

**Поле `sema`** представляет собой семафор, используемый для организации очереди ожидания. Когда горутина не может получить блокировку, она помещается в очередь семафора и переводится в состояние ожидания.

---

## **2. Режимы работы мьютекса**

### **Нормальный режим (Normal Mode)**

В нормальном режиме мьютекс работает по принципу конкурентного захвата. Когда мьютекс разблокируется, проснувшаяся горутина должна конкурировать с новыми горутинами, которые только пытаются захватить блокировку. Это обеспечивает высокую производительность при низкой конкуренции, но может привести к "голоданию" горутин, которые долго ждут в очереди.

### **Режим голодания (Starvation Mode)**

Режим голодания активируется автоматически когда горутина ожидает захвата мьютекса более 1 миллисекунды. В этом режиме приоритет отдается горутинам, которые уже находятся в очереди ожидания, а не новым горутинам. Это гарантирует справедливость (fairness) - горутины получают блокировку в порядке приблизительного времени запроса.

Переключение между режимами происходит динамически на основе времени ожидания. Когда последняя ожидающая горутина получает блокировку, мьютекс возвращается в нормальный режим.

---

## **3. Детальный алгоритм работы Lock()**

```go
func (m *Mutex) Lock() {
    // Быстрая путь: попытка немедленной блокировки через атомарное сравнение-и-замена
    if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
        if race.Enabled {
            race.Acquire(unsafe.Pointer(m))
        }
        return
    }
    
    // Медленный путь: конкурентная блокировка
    m.lockSlow()
}
```

**Алгоритм `lockSlow()` выполняется в цикле и включает следующие этапы:**

1. **Инициализация переменных отслеживания**:
   - `waitStartTime` запоминает время начала ожидания в наносекундах
   - `awoke` флаг указывает была ли горутина разбужена
   - `iter` счетчик итераций для ограничения spin-ожидания

2. **Старая горутина может устанавливать флаг mutexWoken** чтобы указать что она уже проснулась и активно пытается захватить мьютекс, что предотвращает излишнее пробуждение других горутин.

3. **Spin-ожидание активируется при условиях**:
   - Количество процессоров больше 1
   - Количество итераций spin меньше 4
   - Существуют свободные процессоры
   - Локальная очередь выполнения не пуста

4. **В режиме spin горутина активно опрашивает состояние мьютекса** с помощью инструкции `runtime_doSpin()`, которая на x86-64 реализуется как инструкция `PAUSE`, уменьшающая энергопотребление и улучшающая производительность на гипертрединговых процессорах.

5. **После неудачного spin-ожидания** горутина увеличивает счетчик ожидающих и переходит в состояние ожидания на семафоре через вызов `runtime_SemacquireMutex()`.

---

## **4. Детальный алгоритм работы Unlock()**

```go
func (m *Mutex) Unlock() {
    if race.Enabled {
        _ = m.state
        race.Release(unsafe.Pointer(m))
    }

    // Быстрая путь: атомарное снятие блокировки
    new := atomic.AddInt32(&m.state, -mutexLocked)
    if new != 0 {
        // Медленный путь: есть ожидающие горутины
        m.unlockSlow(new)
    }
}
```

**Алгоритм `unlockSlow()` выполняет сложную логику пробуждения:**

1. **Проверка корректности операции**:
   - Если мьютекс уже был разблокирован, генерируется паника
   - Проверяется не находится ли мьютекс в неконсистентном состоянии

2. **Логика пробуждения в нормальном режиме**:
   - Если нет ожидающих горутин или флаги установлены некорректно, просто возвращаемся
   - Если есть ожидающие, но мьютекс заблокирован, установлен флаг woken или нет ожидающих - это указывает на состояние гонки

3. **Логика пробуждения в режиме голодания**:
   - В этом режиме владение мьютексом явно передается следующей ожидающей горутине
   - Счетчик ожидающих уменьшается
   - Устанавливаются соответствующие флаги состояния

4. **Фактическое пробуждение горутины** происходит через вызов `runtime_Semrelease()`, который активирует семафор и помечает одну из ожидающих горутин как готовую к выполнению.

---

## **5. Взаимодействие с планировщиком Go**

### **Система семафоров**

Семафоры в Go реализованы в пакете `runtime/sema.go` и представляют собой сложную структуру данных, которая:

- **Хранит очереди ожидания** для каждого уникального семафора (идентифицируемого адресом)
- **Обеспечивает fair scheduling** - горутины пробуждаются в приблизительном порядке FIFO
- **Интегрируется с планировщиком** через `gopark` и `goready`

**Процесс блокировки на семафоре:**
1. Гортина помещается в очередь ожидания семафора
2. Вызывается `gopark` который переводит горутину в состояние ожидания
3. Планировщик исключает горутину из графа выполнения до ее пробуждения

**Процесс пробуждения:**
1. `semrelease` извлекает горутину из очереди ожидания
2. Вызывается `goready` который помечает горутину как готовую к выполнению
3. Планировщик добавляет горутину в локальную или глобальную очередь выполнения

### **Наносекундные таймеры**

Для определения перехода в режим голодания используется высокоточное время:
```go
waitStartTime := runtime_nanotime()
// ...
if runtime_nanotime()-waitStartTime > starvationThresholdNs {
    // Активируем режим голодания
    starved = true
}
```

Функция `runtime_nanotime()` предоставляет монотонное время с наносекундной точностью, которое не подвержено корректировкам системных часов.

---

## **6. Адаптивные оптимизации производительности**

### **Динамическое spin-ожидание**

Количество spin-итераций адаптируется к характеристикам системы:

- **На системах с большим количеством ядер** допускается более длительное spin-ожидание
- **При высокой загрузке системы** spin-ожидание сокращается чтобы не тратить ресурсы CPU
- **Учитывается тип рабочей нагрузки** - CPU-intensive vs IO-intensive

### **Алгоритм предотвращения инверсии приоритетов**

Хотя Go не использует традиционные приоритеты потоков, мьютекс включает механизмы предотвращения ситуаций когда:

- Гортина удерживающая блокировку не получает времени CPU для ее освобождения
- Множество новых горутин постоянно "перехватывают" блокировку у долго ожидающих

### **Локальные очереди ожидания**

Каждый семафор поддерживает локальную очередь для процессора, что улучшает производительность за счет:

- Уменьшения конкуренции за глобальные锁
- Улучшения локальности кэша процессора
- Снижения накладных расходов на синхронизацию

---

## **7. Примеры работы в различных сценариях**

### **Сценарий 1: Низкая конкуренция**

```go
// Гортина 1
mu.Lock()   // CAS успешен - мгновенный захват
// работа с разделяемыми данными
mu.Unlock() // простой декремент - нет ожидающих

// Гортина 2 (через некоторое время)
mu.Lock()   // CAS успешен - нет конкуренции
```

В этом случае используются только атомарные операции без взаимодействия с планировщиком.

### **Сценарий 2: Высокая конкуренция с короткими блокировками**

```go
// Множество горутин одновременно
for i := 0; i < 100; i++ {
    go func() {
        mu.Lock()   // CAS неуспешен → lockSlow()
        // очень короткая критическая секция
        mu.Unlock() // пробуждение следующей
    }()
}
```

Активируется spin-ожидание и быстрая передача блокировки между горутинами.

### **Сценарий 3: Длительное ожидание**

```go
// Гортина 1 удерживает блокировку долго
mu.Lock()
time.Sleep(10 * time.Millisecond) // долгая работа
mu.Unlock()

// Гортина 2 ждет долго
mu.Lock() // ожидание >1ms → активация режима голодания
```

После 1 миллисекунды ожидания активируется режим голодания, гарантирующий получение блокировки горутиной 2.

---

## **8. Архитектурные особенности реализации**

### **x86-64 архитектура**

- **Атомарные операции** используют LOCK-префикс для обеспечения эксклюзивного доступа к кэш-линии
- **Spin-ожидание** реализовано с инструкцией `PAUSE` которая:
  - Уменьшает энергопотребление в цикле ожидания
  - Увеличивает производительность на гипертрединговых процессорах
  - Предотвращает штрафы за неправильное предсказание переходов

### **ARM64 архитектура**

- **Атомарные операции** используют пары LDREX/STREX (Load Exclusive/Store Exclusive)
- **Memory ordering** обеспечивается через соответствующие барьеры памяти
- **Spin-ожидание** использует адаптированные тайминги для архитектуры ARM

### **WebAssembly (WASM)**

- **Ограниченная поддержка** атомарных операций через WASM instructions
- **Упрощенная логика** без сложного spin-ожидания
- **Эмуляция** некоторых примитивов на уровне рантайма Go

---

## **9. Производительность и характеристика**

### **Временные характеристики операций**

- **Быстрый путь Lock/Unlock**: 2-5 наносекунд (1-2 атомарные операции)
- **Медленный путь без ожидания**: 10-20 наносекунд (несколько атомарных операций + проверки)
- **Переход в ожидание**: 100-200 наносекунд (взаимодействие с планировщиком)
- **Пробуждение из ожидания**: 500-1000 наносекунд (перепланирование горутины)

### **Потребление памяти**

Каждый `sync.Mutex` занимает 8 байт (int32 + uint32), но дополнительно:

- **Очередь ожидания** на семафоре потребляет ~40 байт на ожидающую горутину
- **Системные структуры данных** планировщика добавляют дополнительные накладные расходы

### **Влияние на сборку мусора**

Поле `state` мьютекса сканируется сборщиком мусора как корневой объект, но:

- **Семафоры не содержат указателей** и не требуют специальной обработки
- **Очереди ожидания** интегрированы с системой отслеживания живых объектов

---

**Ссылки на исходный код:**
- [sync/mutex.go](https://github.com/golang/go/blob/master/src/sync/mutex.go)
- [runtime/sema.go](https://github.com/golang/go/blob/master/src/runtime/sema.go)
- [runtime/lock_futex.go](https://github.com/golang/go/blob/master/src/runtime/lock_futex.go)