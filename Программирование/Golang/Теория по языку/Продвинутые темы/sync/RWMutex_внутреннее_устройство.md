---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Sync
  - Mutex
  - RWMutex
  - Внутренее_устройство
Связанные темы:
  - "[[Примитивы sync]]"
---
# **Внутреннее устройство sync.RWMutex в Go**

## **1. Базовая структура и принцип работы**

RWMutex (Reader-Writer Mutex) представляет собой мьютекс с оптимизацией для сценариев "много читателей - мало писателей". Структура построена на основе стандартного мьютекса с добавлением счетчиков читателей.

```go
// Исходный код из src/sync/rwmutex.go
type RWMutex struct {
    w           Mutex  // мьютекс для писателей
    writerSem   uint32 // семафор для ожидания писателей
    readerSem   uint32 // семафор для ожидания читателей
    readerCount int32  // счетчик читателей (отрицательный когда писатель активен)
    readerWait  int32  // количество читателей, ожидающих завершения писателя
}
```

**Назначение полей:**

- **w (Mutex)**: базовый мьютекс, используемый писателями для эксклюзивного доступа
- **writerSem**: семафор, на котором блокируются писатели когда активны читатели или другой писатель
- **readerSem**: семафор, на котором блокируются читатели когда активен писатель
- **readerCount**: комбинированное поле, выполняющее две функции:
  - Положительное значение: количество активных читателей
  - Отрицательное значение: писатель активен или ожидает (значение `rwmutexMaxReaders`)
- **readerWait**: количество читателей, которые все еще активны когда писатель начал ожидание

---

## **2. Алгоритм работы RLock() и RUnlock()**

### **Процесс захвата блокировки на чтение**

```go
func (rw *RWMutex) RLock() {
    if atomic.AddInt32(&rw.readerCount, 1) < 0 {
        // readerCount стал отрицательным - есть активный писатель
        runtime_SemacquireRWMutexR(&rw.readerSem, false, 0)
    }
}
```

**Детальный алгоритм RLock():**

1. **Атомарное увеличение readerCount** на 1 с помощью `atomic.AddInt32`
2. **Проверка знака результата**:
   - Если результат ≥ 0: читатель может немедленно начать чтение
   - Если результат < 0: активен писатель, читатель блокируется на readerSem
3. **Блокировка читателя** происходит через `runtime_SemacquireRWMutexR`, который:
   - Помещает горутину в очередь ожидания читателей
   - Переводит горутину в состояние ожидания до пробуждения писателем

### **Процесс освобождения блокировки чтения**

```go
func (rw *RWMutex) RUnlock() {
    if r := atomic.AddInt32(&rw.readerCount, -1); r < 0 {
        rw.rUnlockSlow(r)
    }
}
```

**Детальный алгоритм RUnlock():**

1. **Атомарное уменьшение readerCount** на 1
2. **Если результат отрицательный** (писатель ожидает), вызывается `rUnlockSlow()`
3. **В rUnlockSlow()**:
   - Уменьшается счетчик `readerWait`
   - Если `readerWait` достигает 0 (все читатели завершили), пробуждается писатель
   - Пробуждение писателя через `runtime_Semrelease(&rw.writerSem, false, 1)`

---

## **3. Алгоритм работы Lock() и Unlock()**

### **Процесс захвата блокировки на запись**

```go
func (rw *RWMutex) Lock() {
    // Сначала захватываем базовый мьютекс для исключения других писателей
    rw.w.Lock()
    
    // Объявляем себя писателем через инверсию знака readerCount
    r := atomic.AddInt32(&rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders
    
    // Ждем пока активные читатели завершат работу
    if r != 0 && atomic.AddInt32(&rw.readerWait, r) != 0 {
        runtime_SemacquireRWMutex(&rw.writerSem, false, 0)
    }
}
```

**Детальный алгоритм Lock():**

1. **Захват базового мьютекса** `w.Lock()` - исключает других писателей
2. **Инверсия readerCount**: вычитание `rwmutexMaxReaders` (1 << 30) делает значение отрицательным, сигнализируя о активном писателе
3. **Сохранение количества активных читателей** в переменной `r`
4. **Если есть активные читатели**:
   - Устанавливается `readerWait` в количество активных читателей
   - Писатель блокируется на `writerSem` до тех пор пока все читатели не завершат работу
5. **Каждый завершающий читатель** уменьшает `readerWait` и последний пробуждает писателя

### **Процесс освобождения блокировки записи**

```go
func (rw *RWMutex) Unlock() {
    // Восстанавливаем readerCount в положительное состояние
    r := atomic.AddInt32(&rw.readerCount, rwmutexMaxReaders)
    
    // Пробуждаем всех заблокированных читателей
    for i := 0; i < int(r); i++ {
        runtime_Semrelease(&rw.readerSem, false, 0)
    }
    
    // Освобождаем базовый мьютекс для других писателей
    rw.w.Unlock()
}
```

**Детальный алгоритм Unlock():**

1. **Восстановление readerCount** добавлением `rwmutexMaxReaders` возвращает его в положительный диапазон
2. **Значение `r`** представляет количество читателей, ожидающих во время активности писателя
3. **Пробуждение всех ожидающих читателей** через цикл `runtime_Semrelease` для каждого читателя
4. **Освобождение базового мьютекса** позволяет другим писателям конкурировать за блокировку

---

## **4. Константы и специальные значения**

```go
const rwmutexMaxReaders = 1 << 30  // 1,073,741,824
```

**Назначение rwmutexMaxReaders:**

- **Разделение диапазонов**: положительные значения для читателей, отрицательные для писателей
- **Обнаружение переполнения**: предотвращает превышение максимального количества читателей
- **Проверка корректности**: вызов RLock() после достижения лимита вызывает панику

**Логика проверки переполнения:**
```go
if atomic.AddInt32(&rw.readerCount, 1) < 0 {
    // В случае переполнения readerCount станет положительным, но меньше 0?
    // На самом деле при достижении rwmutexMaxReaders следующее добавление
    // сделает значение отрицательным, что указывает на ошибку
    if atomic.AddInt32(&rw.readerCount, -1) < 0 {
        throw("sync: RUnlock of unlocked RWMutex")
    }
}
```

---

## **5. Режимы работы и состояния RWMutex**

### **Состояние 1: Свободен (разблокирован)**
```
readerCount = 0
readerWait = 0
w = unlocked
```
- Читатели и писатели могут немедленно захватывать блокировку
- Первый пришедший получает доступ

### **Состояние 2: Активные читатели**
```
readerCount = N (количество активных читателей)
readerWait = 0
w = unlocked
```
- Новые читатели могут присоединяться без блокировки
- Писатели блокируются до завершения всех читателей

### **Состояние 3: Ожидающий писатель**
```
readerCount = -rwmutexMaxReaders + M (M активных читателей)
readerWait = M (количество читателей до пробуждения писателя)
w = locked
```
- Новые читатели блокируются на readerSem
- Активные читатели продолжают работу
- Писатель ожидает на writerSem

### **Состояние 4: Активный писатель**
```
readerCount = -rwmutexMaxReaders
readerWait = 0
w = locked
```
- Все новые читатели и писатели блокируются
- Только текущий писатель имеет доступ

---

## **6. ## Политика справедливости**

RWMutex использует **гибридную политику** с балансом между производительностью читателей и предотвращением полного голодания писателей:

- **Блокировка новых читателей при ожидающем писателе**: Когда писатель начинает ожидание (вызывает `Lock()`), все новые читатели блокируются до его завершения
- **Приоритет текущих читателей**: Активные читатели продолжают работу до завершения, писатель ожидает их окончания через счетчик `readerWait`
- **Гарантия прогресса писателей**: После блокировки новых читателей, писатель гарантированно получит доступ после завершения текущего поколения читателей
- **Отсутствие строгого FIFO**: Хотя писатели конкурируют через базовый мьютекс, нет гарантий чередования читателей и писателей

**Механизм предотвращения вечного голодания:**
1. Писатель устанавливает `readerCount` в отрицательное значение при вызове `Lock()`
2. Новые читатели видят отрицательный `readerCount` и блокируются
3. Писатель ожидает только текущих активных читателей через `readerWait`
4. После завершения текущих читателей писатель гарантированно получает эксклюзивный доступ

---
### **## Алгоритм пробуждения с приоритетом писателей**

При разблокировке писателя:

- **Писатели имеют приоритет**: При разблокировке базовый мьютекс `w` освобождается последним, давая писателям преимущество
    
- **Ожидающие читатели пробуждаются**, но должны конкурировать с новыми писателями
    
- **Новые читатели блокируются** если есть ожидающий писатель

---

## **7. Взаимодействие с планировщиком**

### **Семафоры RWMutex**

Используются специализированные версии семафоров:

```go
// Для читателей
runtime_SemacquireRWMutexR(&rw.readerSem, false, 0)

// Для писателей  
runtime_SemacquireRWMutex(&rw.writerSem, false, 0)
```

**Особенности реализации:**

- **Reader-семафор** может пробуждать multiple waiters одновременно
- **Writer-семафор** пробуждает только одного waiter за раз
- **Интеграция с GMP** планировщиком через `gopark` и `goready`

### **Атомарные операции и барьеры памяти**

Все операции с `readerCount` и `readerWait` используют:

- **Atomic операции** для обеспечения видимости изменений между горутинами
- **Неявные барьеры памяти** через атомарные инструкции
- **Sequential consistency** для упорядочивания операций до/после семафорных вызовов

---

## **8. Оптимизации производительности**

### **Быстрый путь для читателей**

В отсутствие конкуренции с писателями:

- **RLock(): 1 атомарная операция** (AddInt32)
- **RUnlock(): 1 атомарная операция** (AddInt32)  
- **Нет системных вызовов** и взаимодействия с планировщиком

### **Ленивая инициализация семафоров**

Семафоры `readerSem` и `writerSem`:

- **Инициализируются при первом использовании**
- **Не потребляют память** пока нет блокировок
- **Управляются runtime** через глобальную таблицу семафоров

### **Batch-пробуждение читателей**

При Unlock() писатель:

- **Пробуждает всех читателей сразу** вместо поочередного пробуждения
- **Уменьшает contention** на семафорах
- **Улучшает scalability** при большом количестве ожидающих читателей

---

## **9. Обработка ошибок и паники**

### **Обнаружение некорректного использования**

```go
func (rw *RWMutex) rUnlockSlow(r int32) {
    if r+1 == 0 || r+1 == -rwmutexMaxReaders {
        throw("sync: RUnlock of unlocked RWMutex")
    }
    // ...
}
```

**Проверяемые условия:**

1. **RUnlock без RLock**: readerCount не должен быть 0 или -rwmutexMaxReaders при вызове RUnlock
2. **Переполнение читателей**: превышение rwmutexMaxReaders вызывает панику
3. **Несбалансированные вызовы**: вызов Unlock() без предшествующего Lock()

### **Восстановление состояний**

При панике в критической секции:

- **RWMutex остается в консистентном состоянии**
- **Другие горутины могут нормально работать** после очистки
- **Не требуется явного восстановления** как в recursive mutex

---

## **10. Сравнительная производительность**

### **Бенчмарки операций**

| Операция | Время (нс) | Атомарные операции | Системные вызовы |
|----------|------------|-------------------|------------------|
| RLock (fast) | 3-5 | 1 | 0 |
| RLock (slow) | 100-200 | 2-3 | 1 |
| Lock (fast) | 20-30 | 3-4 | 0 |
| Lock (slow) | 1000+ | 4-5 | 1-2 |

### **Потребление памяти**

- **Базовая структура**: 20 байт (Mutex: 8б + 2×uint32: 8б + 2×int32: 8б)
- **На ожидающую горутину**: ~40 байт в очереди семафора
- **Семафорные структуры**: разделяются между всеми RWMutex в процессе

### **Scalability характеристика**

- **Читатели**: отлично масштабируются до сотен concurrent readers
- **Писатели**: плохо масштабируются при частых записях
- **Смешанная нагрузка**: эффективен при соотношении read:write > 10:1

---

## **11. Практические примеры работы**

### **Сценарий 1: Только читатели**
```go
var rw sync.RWMutex

// Все горутины работают параллельно
for i := 0; i < 100; i++ {
    go func() {
        rw.RLock()   // быстрый путь, readerCount++
        // чтение данных
        rw.RUnlock() // быстрый путь, readerCount--
    }()
}
```

### **Сценарий 2: Читатели и писатель**
```go
// Писатель захватывает блокировку
rw.Lock()           // readerCount = -maxReaders, ждет активных читателей

// Новые читатели блокируются
go func() {
    rw.RLock()      // блокируется на readerSem, т.к. readerCount < 0
}()

// Активные читатели завершают работу
rw.RUnlock()        // уменьшает readerWait, последний пробуждает писателя

// Писатель завершает работу
rw.Unlock()         // пробуждает всех ожидающих читателей
```

### **Сценарий 3: Конкурирующие писатели**
```go
// Писатель 1
rw.Lock()           // захватывает w, инвертирует readerCount

// Писатель 2  
rw.Lock()           // блокируется на w.Lock(), т.к. писатель 1 активен

// Писатель 1 завершает работу
rw.Unlock()         // пробуждает читателей, затем освобождает w

// Писатель 2 получает w, затем ждет читателей если есть
```

---

**Ссылки на исходный код:**
- [sync/rwmutex.go](https://github.com/golang/go/blob/master/src/sync/rwmutex.go)
- [runtime/sema.go](https://github.com/golang/go/blob/master/src/runtime/sema.go)
- [runtime/lock_sema.go](https://github.com/golang/go/blob/master/src/runtime/lock_sema.go)