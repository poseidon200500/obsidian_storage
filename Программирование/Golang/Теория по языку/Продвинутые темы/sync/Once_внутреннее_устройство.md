---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Sync
  - Once
  - Внутренее_устройство
Связанные темы:
  - "[[Примитивы sync]]"
---

# **Внутреннее устройство sync.Once в Go**

## **1. Базовая структура и принцип работы**

Once обеспечивает однократное выполнение функции даже в условиях конкуренции множества горутин. Структура использует атомарные операции и мьютекс для координации выполнения.

```go
// Исходный код из src/sync/once.go
type Once struct {
    done uint32 // флаг завершения выполнения (0 - не выполнено, 1 - выполнено)
    m    Mutex  // мьютекс для синхронизации конкурентных вызовов
}
```

**Назначение полей:**

- **done (uint32)**: атомарный флаг, указывающий на состояние выполнения:
  - `0`: функция еще не выполнялась
  - `1`: функция уже была выполнена
- **m (Mutex)**: мьютекс для защиты критической секции при первом выполнении

**Общий принцип работы:**
Once гарантирует, что переданная функция выполнится ровно один раз, независимо от количества вызовов Do(). Первая горутина, достигающая Do(), выполняет функцию, все последующие вызовы немедленно возвращаются без выполнения.

---

## **2. Алгоритм работы Do()**

Метод `Do()` принимает функцию и обеспечивает ее однократное выполнение. Алгоритм оптимизирован для минимизации накладных расходов после первого выполнения.

```go
func (o *Once) Do(f func()) {
    // Быстрый путь: проверка атомарного флага done
    if atomic.LoadUint32(&o.done) == 0 {
        // Медленный путь: необходимо выполнить функцию
        o.doSlow(f)
    }
}
```

**Детальный алгоритм doSlow():**

```go
func (o *Once) doSlow(f func()) {
    o.m.Lock() // Захватываем мьютекс
    defer o.m.Unlock() // Гарантируем освобождение
    
    // Двойная проверка под мьютексом
    if o.done == 0 {
        // Еще не выполнено - устанавливаем флаг и выполняем функцию
        defer atomic.StoreUint32(&o.done, 1)
        f() // Выполняем пользовательскую функцию
    }
}
```

**Пошаговое выполнение Do():**

1. **Атомарная проверка done**: `atomic.LoadUint32(&o.done) == 0`
   - Если `1`: немедленный возврат (быстрый путь)
   - Если `0`: переход к медленному пути

2. **Захват мьютекса**: `o.m.Lock()` - только одна горутина проходит дальше

3. **Двойная проверка**: `if o.done == 0` (уже под защитой мьютекса)
   - Защита от race condition между проверкой и захватом мьютекса

4. **Отложенная установка флага**: `defer atomic.StoreUint32(&o.done, 1)`
   - Гарантирует установку флага даже при панике в f()

5. **Выполнение функции**: `f()` - выполнение пользовательской функции

6. **Освобождение мьютекса**: через defer

---

## **3. Модель памяти и атомарные операции**

### **Используемые атомарные примитивы**

```go
atomic.LoadUint32(&o.done)    // Чтение с гарантией visibility
atomic.StoreUint32(&o.done, 1) // Запись с memory barrier
```

### **Гарантии памяти**

- **LoadUint32**: обеспечивает, что чтение флага done видит последнюю записанную версию
- **StoreUint32**: гарантирует, что запись флага done становится видимой другим горутинам
- **Memory ordering**: операция store создает happens-before отношение с последующими load операциями

### **Схема happens-before**

```
Горутина A (первый вызов)          Горутина B (последующий вызов)
--------------------------          -----------------------------
1. atomic.LoadUint32 == 0
2. o.m.Lock()
3. Проверка o.done == 0
4. Выполнение f()
5. atomic.StoreUint32(1) ---------> 6. atomic.LoadUint32 == 1 (возврат)
6. o.m.Unlock()
```

---

## **4. Обработка паники и ошибок**

### **Поведение при панике в функции**

```go
defer atomic.StoreUint32(&o.done, 1)
f() // Если f() паникует, флаг все равно устанавливается в 1
```

**Важные особенности:**
- Флаг `done` устанавливается в 1 даже при панике в f()
- Последующие вызовы Do() не будут пытаться выполнить f() снова
- Паника распространяется нормально к caller'у

### **Пример с паникой**

```go
var once sync.Once

// Первый вызов - паника
func() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered:", r)
        }
    }()
    once.Do(func() {
        panic("something went wrong")
    })
}()

// Последующие вызовы - ничего не происходит
once.Do(func() {
    fmt.Println("This will never print")
})
```

### **Проверки корректности**

Once не выполняет явных проверок на:
- Nil функции (вызов nil функции вызовет панику в обычном режиме)
- Реентерабельные вызовы (вызов Do() из самой f() приведет к deadlock)

---

## **5. Оптимизации производительности**

### **Быстрый путь (после первого выполнения)**

- **1 атомарная операция**: LoadUint32
- **0 блокировок**: нет взаимодействия с мьютексом
- **Время выполнения**: 2-5 наносекунд

### **Медленный путь (первое выполнение)**

- **2 атомарные операции**: LoadUint32 + StoreUint32
- **1 захват мьютекса**: блокировка для координации
- **Время выполнения**: 20-100+ наносекунд (зависит от f())

### **Двойная проверка (double-checked locking)**

Паттерн double-checked locking предотвращает ненужные блокировки:

```go
if atomic.LoadUint32(&o.done) == 0 { // Первая проверка (без блокировки)
    o.m.Lock()                       // Захват мьютекса
    if o.done == 0 {                 // Вторая проверка (под мьютексом)
        // Выполнение функции
    }
    o.m.Unlock()
}
```

**Преимущества double-checked locking:**
- Избегает блокировок после первого выполнения
- Гарантирует однократное выполнение при конкуренции
- Минимизирует накладные расходы в steady state

---

## **6. Состояния Once и переходы**

### **Состояние 1: Не выполнено (Initial)**
```
done = 0
m = unlocked
```
- Первый вызов Do() выполнит функцию
- Все горутины проходят первую проверку и пытаются захватить мьютекс

### **Состояние 2: Выполняется (Executing)**
```
done = 0
m = locked (одной горутиной)
```
- Одна горутина захватила мьютекс и выполняет функцию
- Остальные горутины блокированы на мьютексе

### **Состояние 3: Выполнено (Completed)**
```
done = 1
m = unlocked
```
- Функция выполнена (успешно или с паникой)
- Все последующие вызовы возвращаются немедленно

### **Диаграмма переходов**
```
Initial (done=0)
    │
    ↓ (первый вызов Do())
Executing (m=locked)
    │
    ↓ (завершение f())
Completed (done=1)
```

---

## **7. Взаимодействие с планировщиком**

### **Блокировка на мьютексе**

Когда несколько горутин одновременно вызывают Do() в первый раз:

1. **Одна горутина** захватывает мьютекс и выполняет функцию
2. **Остальные горутины** блокируются на `o.m.Lock()`
3. **Планировщик** переводит заблокированные горутины в состояние ожидания
4. **Runtime мьютекс** помещает ожидающие горутины в FIFO-очередь

### **Пробуждение горутин**

При разблокировке мьютекса выполненной горутиной:

1. **Планировщик будит горутины по одной** из очереди ожидания
2. **Первая пробужденная горутина** проверяет `atomic.LoadUint32(&o.done) == 1`
3. **Обнаружив выполнение**, горутина немедленно возвращается из Do()
4. **Следующая горутина** пробуждается, проверяет `done` и возвращается
5. **Процесс повторяется** пока все ожидающие горутины не будут пробуждены
    

**Ключевой момент:** Планировщик не будит все горутины одновременно, а последовательно обрабатывает очередь ожидания, но каждая пробужденная горутина сразу видит `done == 1` и не пытается повторно захватить мьютекс.

---

## **8. Практические примеры работы**

### **Сценарий 1: Простая инициализация**
```go
var (
    once sync.Once
    config map[string]string
)

func loadConfig() {
    once.Do(func() {
        fmt.Println("Loading configuration...")
        config = readFromFile()
    })
}

// Множественные concurrent вызовы
for i := 0; i < 10; i++ {
    go loadConfig()
}
// Output: "Loading configuration..." (только один раз)
```

**Состояния Once:**
- До вызова: done=0
- Во время первого Do(): мьютекс захвачен, функция выполняется
- После: done=1, последующие вызовы используют быстрый путь

### **Сценарий 2: Конкуренция при инициализации**
```go
var once sync.Once
var resource *Resource

func getResource() *Resource {
    once.Do(func() {
        fmt.Println("Initializing resource...")
        resource = &Resource{data: "expensive"}
        time.Sleep(100 * time.Millisecond) // Имитация долгой инициализации
    })
    return resource
}

// 100 горутин одновременно пытаются получить ресурс
for i := 0; i < 100; i++ {
    go func() {
        _ = getResource()
    }()
}
```

**Поведение:**
- 1 горутина: захватывает мьютекс, выполняет инициализацию
- 99 горутин: блокируются на мьютексе, затем используют быстрый путь

### **Сценарий 3: Once внутри Once (deadlock)**
```go
var once1, once2 sync.Once

once1.Do(func() {
    once2.Do(func() {
        fmt.Println("Inner once")
    })
})
// Безопасно - не вызывает deadlock

once1.Do(func() {
    once1.Do(func() {
        fmt.Println("This will deadlock!")
    })
})
// Deadlock - повторный захват того же мьютекса
```

---

## **9. Производительность и характеристики**

### **Временные затраты**

| Операция | Время (нс) | Атомарные операции | Блокировки |
|----------|------------|-------------------|------------|
| Do() (fast path) | 2-5 | 1 | 0 |
| Do() (slow path, no contention) | 20-50 | 2 | 1 |
| Do() (slow path, with contention) | 100-1000+ | 2 | 1 + ожидание |

### **Потребление памяти**

- **Базовая структура**: 8 байт (uint32: 4б + Mutex: 4б)
- **Нет динамических аллокаций** в типичном использовании
- **Мьютекс добавляет** ~8 байт для семафоров при блокировках

### **Scalability**

- **Отлично масштабируется** для read-heavy workload после инициализации
- **При конкуренции на инициализации** performance зависит от времени выполнения f()
- **Нет bottleneck'ов** после первого выполнения

---

## **10. Сравнение с альтернативными подходами**

### **Once vs Mutex + флаг**
```go
// С использованием Mutex
var mu sync.Mutex
var initialized bool

func initialize() {
    mu.Lock()
    defer mu.Unlock()
    if !initialized {
        initFunction()
        initialized = true
    }
}

// С использованием Once
var once sync.Once
func initialize() {
    once.Do(initFunction)
}
```

**Преимущества Once:**
- Более чистый API
- Лучшая производительность после инициализации
- Гарантированная обработка паники

### **Once vs atomic.CompareAndSwap**
```go
var done uint32

func initialize() {
    if atomic.CompareAndSwapUint32(&done, 0, 1) {
        initFunction()
    }
}
```

**Проблемы CAS подхода:**
- Multiple горутины могут "победить" в CAS и выполнить функцию
- Нет координации - возможна гонка при инициализации

### **Once vs package-level init()**
```go
// С init()
var config map[string]string

func init() {
    config = loadConfig()
}

// С Once
var (
    once sync.Once
    config map[string]string
)

func getConfig() map[string]string {
    once.Do(func() { config = loadConfig() })
    return config
}
```

**Преимущества Once:**
- Ленивая инициализация
- Возможность обработки ошибок
- Контроль времени инициализации

---

## **11. Особые случаи и предостережения**

### **Реентерабельные вызовы**
```go
var once sync.Once

once.Do(func() {
    once.Do(func() {
        fmt.Println("Inner call")
    })
})
// Deadlock - повторный захват того же мьютекса
```

### **Изменяемая функция**
```go
var once sync.Once
f1 := func() { fmt.Println("Function 1") }
f2 := func() { fmt.Println("Function 2") }

once.Do(f1)
once.Do(f2) // f2 не выполнится - Once уже "сработал"
```

### **Once как часть структуры**
```go
type Service struct {
    initOnce sync.Once
    cache    map[string]string
}

func (s *Service) init() {
    s.initOnce.Do(func() {
        s.cache = make(map[string]string)
    })
}
```

---

**Ссылки на исходный код:**
- [sync/once.go](https://github.com/golang/go/blob/master/src/sync/once.go)
- [Тесты Once](https://github.com/golang/go/blob/master/src/sync/once_test.go)
- [Atomic операции](https://github.com/golang/go/blob/master/src/sync/atomic/doc.go)