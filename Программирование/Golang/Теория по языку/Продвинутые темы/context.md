---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Продвинутые_темы
Связанные темы:
---
# **Пакет context в Go**  
*Управление жизненным циклом горутин и распределенных операций*

## Введение в контексты

Контекст в Go — это механизм для передачи метаданных, управления таймаутами и отмены операций across API границам. Он решает критически важные задачи в конкурентном программировании: контроль времени выполнения операций, координация отмены связанных задач и безопасная передача scope-специфичных данных.

Контексты образуют древовидную структуру, где отмена родительского контекста автоматически распространяется на всех потомков. Это обеспечивает согласованное управление жизненным циклом распределенных операций.

```go
// Древовидная структура наследования контекстов
context.Background() 
       │
       ├── context.WithCancel() 
       │     │
       │     ├── context.WithValue() 
       │     │
       │     └── context.WithTimeout()
       │
       ├── context.WithDeadline()
       │     │
       │     └── context.WithValue()
       │
       └── context.TODO()
             │
             └── context.WithCancel()

// Направление распространения отмены:
// Родительская отмена → Дочерние контексты → Внучатые контексты

```
---

## **1. Базовые виды контекстов**

### **Background() - корневой контекст**
```go
ctx := context.Background()
```
**Назначение**: Фундаментальный, никогда не отменяемый контекст. Используется как корневой элемент для создания производных контекстов.

**Применение**:
- main-функция
- Инициализация тестов
- Создание корневых контекстов для серверов

**Особенности**: Не имеет таймаута, дедлайна и значений.

### **TODO() - заглушка для разработки**
```go
ctx := context.TODO()
```
**Назначение**: Заглушка для мест, где контекст нужен, но пока не определен какой именно. Указывает на то, что в будущем нужно заменить на конкретный контекст.

**Применение**:
- Временное решение в процессе разработки
- Места, где API требует контекст, но он еще не продуман

**Особенности**: Поведение аналогично Background(), но семантически указывает на незавершенность.

---

## **2. Контексты с отменой**

### **WithCancel() - ручная отмена**
```go
ctx, cancel := context.WithCancel(parent)
```
**Назначение**: Создает контекст, который может быть отменен явным вызовом функции cancel().

**Механизм работы**:
- `cancel()` закрывает канал `Done()`
- Отмена распространяется на все дочерние контексты
- Многократный вызов `cancel()` безопасен

**Применение**:
- Управление группой связанных горутин
- Ручное прерывание долгих операций
- Обработка пользовательских прерываний

### **WithTimeout() - отмена по времени**
```go
ctx, cancel := context.WithTimeout(parent, 5*time.Second)
```
**Назначение**: Автоматическая отмена через указанный промежуток времени.

**Механизм работы**:
- Внутренний таймер запускается при создании
- По истечении времени контекст автоматически отменяется
- `cancel()` можно вызвать досрочно

**Применение**:
- HTTP-запросы с таймаутом
- Ограничение времени выполнения операций
- Защита от вечно выполняющихся задач

### **WithDeadline() - отмена к моменту времени**
```go
deadline := time.Now().Add(2 * time.Hour)
ctx, cancel := context.WithDeadline(parent, deadline)
```
**Назначение**: Отмена в конкретный момент времени.

**Механизм работы**:
- Использует абсолютное время вместо относительного
- Автоматическая отмена при наступлении дедлайна
- Можно отменить досрочно через `cancel()`

**Применение**:
- Операции, которые должны завершиться к определенному времени
- Планировщики задач
- Батч-обработка с временными ограничениями
---
# **3. context.WithoutCancel() - изоляция отмены**

## **Назначение и принцип работы**

`context.WithoutCancel()` создает новый контекст, который наследует все значения и дедлайны родительского контекста, но НЕ наследует механизм отмены. Это позволяет изолировать определенные операции от отмены родительского контекста.

go

// Создание контекста без отмены
ctx := context.WithoutCancel(parentContext)

## **Механизм работы**

### **Поведение при отмене родителя:**

text

Родительский контекст отменяется → Безотменный контекст продолжает работать
     │
     ├── Done() - никогда не закрывается
     ├── Err() - всегда возвращает nil  
     └── Deadline() - наследуется от родителя
---

## **4. Контексты с метаданными**

### **WithValue() - передача значений**
```go
type keyType string
ctx := context.WithValue(parent, keyType("user"), "alice")
```
**Назначение**: Передача scope-специфичных данных через цепочку вызовов.

**Механизм работы**:
- Значения immutable - каждое WithValue создает новый контекст
- Данные доступны только в поддереве контекста
- Типобезопасность через конкретные типы ключей

**Правила использования**:
- Ключи должны быть сравниваемыми и не быть встроенными типами
- Значения должны быть потокобезопасными
- Не использовать для передачи обязательных параметров функций

**Применение**:
- Трассировка запросов (request ID)
- Аутентификационные данные
- Метаданные для логирования

---

## **5. Композитные контексты**

### **Комбинация свойств**
Контексты можно комбинировать, создавая цепочки с множественными свойствами:
	
```go
// Контекст с таймаутом и метаданными
timeoutCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
defer cancel()

requestCtx := context.WithValue(timeoutCtx, requestIDKey, "req-123")
```

**Приоритеты наследования**:
1. Отмена родительского контекста имеет высший приоритет
2. Таймауты и дедлайны работают независимо
3. Значения объединяются (новые перезаписывают сталые с одинаковыми ключами)

---

## **5. Внутреннее устройство контекстов**

### **Интерфейс Context**
```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
```

### **Типы ошибок**
- `context.Canceled` - при явной отмене
- `context.DeadlineExceeded` - при срабатывании таймаута/дедлайна

### **Древовидная структура**
Все контексты образуют дерево, где:
- Background() и TODO() - корневые узлы
- WithCancel/WithTimeout/WithDeadline/WithValue - производные узлы
- Отмена распространяется вниз по иерархии

---
