---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Пакеты
  - Продвинутые_темы
Связанные темы:
---
# **Пакет container в Go**

Пакет `container` предоставляет реализации трех базовых структур данных:
1. Кольцевые буферы (`ring`)
2. Кучи (`heap`)
3. Двусвязные списки (`list`)

## **1. Кольцевые буферы (ring)**

### **Базовое использование**
```go
import "container/ring"

func main() {
    // Создание кольца из 3 элементов
    r := ring.New(3)

    // Заполнение кольца
    for i := 1; i <= 3; i++ {
        r.Value = i
        r = r.Next()
    }

    // Итерация по кольцу
    r.Do(func(x interface{}) {
        fmt.Println(x) // 1, 2, 3
    })
}
```

### **Ключевые методы:**
| Метод       | Описание                          |
|-------------|-----------------------------------|
| `Next()`    | Следующий элемент                 |
| `Prev()`    | Предыдущий элемент                |
| `Move(n)`   | Перемещение на n элементов        |
| `Link(r)`   | Объединение двух колец            |
| `Unlink(n)` | Удаление n элементов из кольца    |

### **Практическое применение:**
- Реализация циклических буферов
- Round-robin алгоритмы
- Кольцевые очереди

## **2. Кучи (heap)**

### **Требования к реализации:**
```go
type Interface interface {
    sort.Interface
    Push(x interface{})
    Pop() interface{}
}
```

### **Пример min-кучи:**
```go
import (
    "container/heap"
    "fmt"
)

type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func main() {
    h := &IntHeap{2, 1, 5}
    heap.Init(h)
    heap.Push(h, 3)
    
    for h.Len() > 0 {
        fmt.Printf("%d ", heap.Pop(h)) // 1 2 3 5
    }
}
```

### **Основные операции:**
| Операция      | Сложность | Описание                |
|---------------|-----------|-------------------------|
| `Init`        | O(n)      | Построение кучи         |
| `Push`        | O(log n)  | Добавление элемента     |
| `Pop`         | O(log n)  | Извлечение минимума     |
| `Remove`      | O(log n)  | Удаление по индексу     |
| `Fix`         | O(log n)  | Восстановление кучи     |

### **Применение:**
- Приоритетные очереди
- Алгоритм Дейкстры
- Управление задачами по приоритету

## **3. Двусвязные списки (list)**

### **Базовые операции:**
```go
import "container/list"

func main() {
    l := list.New()
    
    // Добавление элементов
    l.PushBack(1)  // [1]
    l.PushFront(0) // [0, 1]
    l.PushBack(2)  // [0, 1, 2]
    
    // Итерация
    for e := l.Front(); e != nil; e = e.Next() {
        fmt.Println(e.Value) // 0, 1, 2
    }
    
    // Удаление
    l.Remove(l.Front()) // [1, 2]
}
```

### **Методы списка:**
| Метод                | Описание                          |
|----------------------|-----------------------------------|
| `PushBack(v)`        | Добавление в конец                |
| `PushFront(v)`       | Добавление в начало               |
| `InsertBefore(v,e)`  | Вставка перед элементом           |
| `InsertAfter(v,e)`   | Вставка после элемента            |
| `MoveToFront(e)`     | Перемещение в начало              |
| `MoveToBack(e)`      | Перемещение в конец               |
| `Remove(e)`          | Удаление элемента                 |

### **Преимущества перед slice:**
1. O(1) вставка/удаление в любом месте
2. Нет затрат на копирование при расширении
3. Удобные операции перемещения элементов

### **Недостатки:**
1. Нет индексации
2. Больший расход памяти
3. Медленный доступ по позиции

## **Сравнение структур**

| Структура | Вставка | Удаление | Доступ | Память | Использование         |
|-----------|---------|----------|--------|--------|-----------------------|
| `ring`    | O(1)    | O(1)     | O(n)   | Малая  | Циклические буферы    |
| `heap`    | O(log n)| O(log n) | O(1)*  | Средняя| Приоритетные очереди  |
| `list`    | O(1)    | O(1)     | O(n)   | Большая| Списки с частыми изменениями |

*Доступ только к минимальному/максимальному элементу

## **Практические советы**

1. **Для ring:**
   - Идеален для фиксированных по размеру буферов
   - Используйте `Do()` для безопасной итерации

2. **Для heap:**
   - Всегда вызывайте `Init()` перед использованием
   - Для max-кучи инвертируйте `Less()`

3. **Для list:**
   - Используйте как основу для LRU-кэша
   - Храните элементы в `map` для быстрого доступа

```go
// Пример LRU-кэша на list + map
type LRU struct {
    list *list.List
    cache map[string]*list.Element
    capacity int
}
```

Пакет `container` предоставляет базовые реализации, которые можно адаптировать под конкретные задачи, сочетая их с другими структурами данных Go.