---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Продвинутые_темы
Связанные темы:
---
# **Трассировка исполнения в Go**

---

## **1. Использование runtime/trace**

### **Запись трассировки**
```go
import "runtime/trace"

func main() {
    f, _ := os.Create("trace.out")
    defer f.Close()
    
    trace.Start(f)
    defer trace.Stop()
    
    // Ваш код для анализа
    myApp()
}
```

### **Анализ трассы**
```bash
go tool trace trace.out
```

**Что показывает:**
- Временную шкалу выполнения горутин
- Системные вызовы
- События сборки мусора
- Блокировки

---

## **2. Визуализация горутин**

### **Ключевые метрики**
| Метрика            | Описание                          |
|--------------------|-----------------------------------|
| Goroutine count    | Количество активных горутин       |
| Execution time     | Время выполнения                 |
| Block time         | Время в ожидании                 |
| Syscall duration   | Длительность системных вызовов   |

### **Типичные проблемы**
- **Утечки горутин**: бесконечно растущее количество
- **Долгие блокировки**: превышение 100ms на одном примитиве
- **Частые переключения**: >1000 переключений/сек

---

## **3. Анализ блокировок**

### **Основные источники**
1. **Каналы**
   ```go
   ch := make(chan int)
   ch <- 42  // Блокировка, если нет читателя
   ```
   
2. **Мьютексы**
   ```go
   var mu sync.Mutex
   mu.Lock()  // Блокировка при занятом мьютексе
   ```

3. **Системные вызовы**
   ```go
   resp, _ := http.Get("...")  // Блокировка на IO
   ```

### **Как находить в трассе:**
1. Ищем длительные (красные) участки на временной шкале
2. Проверяем тип блокировки (channel, mutex, etc)
3. Анализируем стек вызовов

---

## **4. Идентификация узких мест**

### **Методика анализа**
1. **CPU-bound проблемы**:
   - Долгие непрерывные участки выполнения
   - Нет периодов ожидания

2. **IO-bound проблемы**:
   - Частые короткие выполнения
   - Много времени в syscall

3. **Конкурентные проблемы**:
   - Большое количество переключений
   - Долгие блокировки

### **Пример оптимизации**
**До:**
```go
for i := 0; i < 1000; i++ {
    process(data[i])  // Последовательная обработка
}
```

**После:**
```go
var wg sync.WaitGroup
for i := 0; i < 1000; i++ {
    wg.Add(1)
    go func(i int) {
        defer wg.Done()
        process(data[i])  // Параллельная обработка
    }(i)
}
wg.Wait()
```

---

## **5. Практические примеры**

### **Анализ deadlock**
```go
func deadlock() {
    ch := make(chan int)
    <-ch  // Вечная блокировка
}
```
**В трассе:**  
- Горутина в состоянии "blocked" бесконечно
- Нет других активных горутин

### **Оптимизация worker pool**
```go
// До
go func() {
    for task := range tasks {
        process(task)  // Нет ограничения параллелизма
    }
}()

// После
sem := make(chan struct{}, 10)  // Ограничение в 10 воркеров
for task := range tasks {
    sem <- struct{}{}
    go func(t Task) {
        defer func() { <-sem }()
        process(t)
    }(task)
}
```

---

## **6. Интеграция с pprof**

### **Комбинированный анализ**
```bash
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/profile
go tool trace trace.out
```

**Что дает:**
1. **pprof**: Точечный анализ потребления CPU
2. **trace**: Временная динамика выполнения

---

## **7. Ограничения трассировки**

1. **Накладные расходы**:  
   - Увеличивает время выполнения на 5-10%
   - Может влиять на реальное поведение системы

2. **Ограниченная детализация**:  
   - Не показывает содержимое переменных
   - Нет стека вызовов для всех событий

3. **Объем данных**:  
   - Длительные трассы занимают гигабайты

---

**Когда использовать:**  
- Для анализа конкурентных проблем  
- При диагностике "подвисаний"  
- Для оптимизации сложных конвейеров  

**Когда не использовать:**  
- Для профилирования CPU (лучше pprof)  
- В production без необходимости  
- Для коротких (<1s) операций  

Дополнительно:  
[Официальная документация](https://golang.org/pkg/runtime/trace/)  
[Примеры анализа трасс](https://github.com/golang/go/wiki/Tracing)