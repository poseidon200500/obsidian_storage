---
tags:
  - Программирование
  - Теория_по_языку_Golang
Подробнее:
  - "[[itab кэш]]"
---

# **Type Assertion**



**Type assertion** — это механизм проверки и извлечения динамического типа из значения интерфейса. Его работа напрямую зависит от внутреннего устройства интерфейсов, которое мы разбирали (`itab`, `_type`, `hash`).

## **Синтаксис и варианты**

```go
val, ok := interfaceVar.(ConcreteType) // Безопасная проверка (не паникует)
val := interfaceVar.(ConcreteType)     // Небезопасная проверка (паникует при неудаче)
```

---

## **Как это работает внутри (на примере `iface`)**

Рассмотрим процесс на примере:
```go
var s Speaker = Dog{}
dog, ok := s.(Dog) // Type assertion к типу Dog
```

### **1. Проверка на nil**

Первое, что делает runtime — проверяет, не является ли само значение интерфейса `nil`.
```go
if s.tab == nil { // iface is nil
    ok = false
    return
}
```
Если `s` — nil-интерфейс, проверка всегда fails.

### **2. Быстрая проверка по хешу (самый частый случай)**

Это **ключевая оптимизация**. В каждом `itab` и в каждом `_type` есть поле `hash`.

```go
// Получаем itab из интерфейса
itab := s.tab

// Смотрим на тип, к которому делаем assertion (ConcreteType)
targetType := getType(Dog)

// СРАВНЕНИЕ ХЕШЕЙ:
if itab._type.hash == targetType.hash {
    // Хеши совпали! Типы с очень высокой вероятностью одинаковы.
    // Делаем быструю проверку указателей для полной уверенности.
    if itab._type == targetType {
        dog = *(*Dog)(s.data) // Извлекаем данные
        ok = true
        return
    }
}
```
**Важно:** Хеш вычисляется один раз для каждого типа при компиляции и уникален для разных типов. Совпадение хешей — почти 100% гарантия совпадения типов.

### **3. Медленный путь: если хеши не совпали**

Если хеши разные, типы гарантированно разные. `ok` сразу становится `false`.
```go
} else {
    ok = false
    return
}
```

### **4. Специальный случай: assertion к интерфейсу**

Особый случай — это когда мы делаем assertion не к конкретному типу, а к другому интерфейсу.

```go
var s Speaker = Dog{}
var w io.Writer
w, ok = s.(io.Writer) // Проверка, реализует ли Dog интерфейс io.Writer
```

В этом случае алгоритм другой:
1.  Runtime ищет в кэше `itab` для пары `(Конкретный тип из s, целевой интерфейс)`.
    *   Конкретный тип из `s` — это `s.tab._type` (в нашем случае `Dog`).
    *   Целевой интерфейс — `io.Writer`.
2.  Если такая `itab` уже существует — значит, тип `Dog` реализует `io.Writer`. Успех.
3.  Если не существует — runtime пытается ее построить, проверяя, есть ли у типа `Dog` все методы, требуемые `io.Writer`.
    *   Если все методы есть — создается `itab`, assertion успешен.
    *   Если нет — assertion fails.

Это более дорогая операция, чем assertion к конкретному типу.

---

## **Детали реализации для пустого интерфейса (`eface`)**

Для пустого интерфейса логика похожа, но проще, так как у него нет `itab`.

```go
var any interface{} = Dog{}
dog, ok := any.(Dog)
```

1.  Проверка `any._type == nil`. Если да — `ok = false`.
2.  Сравнение хеша типа из `any._type.hash` с хешем целевого типа `Dog`.
3.  Если хеши совпали, проверяются указатели `any._type == targetType`.

---

## **Почему паника возникает в небезопасном варианте?**

В небезопасном варианте (`val := interfaceVar.(ConcreteType)`) логика та же самая. Но если на шаге 2 хеши не совпали (типы разные), вместо возврата `ok = false` runtime немедленно вызывает **панику**.

```go
if itab._type.hash != targetType.hash {
    panic("interface conversion: ...") // Вызов паники
}
```

---

## **Итог: алгоритм type assertion**

1.  **Проверить на nil** само значение интерфейса.
2.  **Сравнить хеши** динамического типа и целевого типа.
    *   Хеши разные → **FAIL**.
    *   Хеши совпали → перейти к шагу 3.
3.  **Сравнить указатели** на `_type` для окончательной проверки.
    *   Указатели совпали → **SUCCESS**, извлечь данные из `data`.
    *   Указатели разные → **FAIL**.
4.  **Для assertion к интерфейсу:** вместо шагов 2-3 происходит **поиск или создание `itab`** для пары (конкретный тип, целевой интерфейс).

Эта схема с быстрой проверкой хеша и медленной проверкой указателей делает type assertion в Go очень эффективным в подавляющем большинстве случаев.