---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Основы_языка_Golang
Связанные темы:
  - "[[Специальные типы]]"
---
# **Указатели в Go: полное руководство**  

---

## **1. Основные понятия**  
Указатель — переменная, хранящая **адрес памяти** другой переменной.  

### **Базовый синтаксис**  
```go
var x int = 10
ptr := &x  // & — оператор взятия адреса
fmt.Println(*ptr) // * — оператор разыменования
*ptr = 20  // Изменение значения через указатель
```

### **Нулевое значение**  
- Неинициализированный указатель равен `nil`  
- Попытка разыменования `nil`-указателя вызывает панику:  
  ```go
  var ptr *int
  fmt.Println(*ptr) // panic: runtime error
  ```

---

## **2. Ключевые особенности**  

### **a) Передача в функции**  
Указатели позволяют модифицировать исходные переменные:  
```go
func increment(n *int) {
    *n++
}

func main() {
    x := 5
    increment(&x)
    fmt.Println(x) // 6
}
```

### **b) Указатели на структуры**  
Используются для избежания копирования:  
```go
type User struct {
    Name string
}

func (u *User) Rename(name string) {
    u.Name = name // Изменяет оригинальную структуру
}
```

### **c) Сравнение указателей**  
Указатели равны, если ссылаются на **одну и ту же** переменную:  
```go
a, b := 10, 10
ptr1, ptr2 := &a, &a
ptr3 := &b

fmt.Println(ptr1 == ptr2) // true
fmt.Println(ptr1 == ptr3) // false, даже если значения равны
```

---

## **3. Опасные моменты**  

### **a) Висячие указатели**  
Указатель может ссылаться на несуществующую память:  
```go
func createPointer() *int {
    x := 10
    return &x // Опасность: x уничтожится после выхода из функции
}
```

### **b) Утечки памяти**  
Указатели могут мешать сборщику мусора:  
```go
var globalPtr *[]byte

func process() {
    data := make([]byte, 100MB)
    globalPtr = &data // data не будет очищена GC
}
```

### **c) Проблемы с concurrency**  
Общие данные требуют синхронизации:  
```go
var counter *int

go func increment() {
    *counter++ // Data race!
}
```

---

## **4. Практические рекомендации**  

1. **Когда использовать:**  
   - Для модификации больших структур  
   - При работе с API, требующими указателей  
   - В реализациях структур данных (деревья, графы)  

2. **Когда избегать:**  
   - С простыми типами (`int`, `bool` и т.д.)  
   - В immutable-подходах  
   - Если есть риск создания висячих ссылок  

3. **Альтернативы:**  
   - Возвращайте значения вместо модификации через указатели  
   - Используйте sync.Pool для временных объектов  


---

**Дополнительно:**  
- [Официальная документация](https://go.dev/ref/spec#Pointer_types)  
- [Effective Go: Указатели](https://go.dev/doc/effective_go#pointers)  

--- 

