---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Основы_языка_Golang
  - map
  - Внутренее_устройство
Связанные темы:
  - "[[Мапы]]"
  - "[[Хеш-таблицы]]"
---
### **Внутреннее устройство map в Go**

#### **1. Базовая структура и принцип работы**
Map в Go реализована как хеш-таблица с динамическим расширением. Основные компоненты:

```go
type hmap struct {
    count     int       // количество элементов
    B         uint8     // log2 от числа бакетов (2^B)
    buckets   unsafe.Pointer // массив бакетов
    oldbuckets unsafe.Pointer // предыдущий массив при расширении
    // ... другие служебные поля
}
```

**Особенности работы:**
- При создании map выделяется начальный массив из 2^B бакетов
- Каждый бакет содержит:
  - 8 слотов для ключей
  - 8 слотов для значений
  - массив tophash (первые 8 бит хеша каждого ключа)
  - указатель на overflow-бакет (при переполнении)

#### **2. Процесс вставки и поиска**
**До переполнения:**
1. Хеш-функция вычисляет хеш ключа
2. Младшие `B` бит хеша определяют номер бакета
3. Старшие 8 бит (tophash) сохраняются для быстрого сравнения
4. Ключ и значение сохраняются в первый свободный слот бакета

**При поиске:**
1. Вычисляется хеш ключа
2. Находится нужный бакет
3. Последовательно проверяются tophash, затем ключи в слотах

#### **3. Overflow-бакеты и переполнение**
Когда все 8 слотов в бакете заняты:
1. Создается новый overflow-бакет
2. Новые элементы добавляются в overflow-бакет
3. Бакеты связываются в односвязный список

**Особенности:**
- Go старается минимизировать количество overflow-бакетов
- При достижении определенного количества overflow-бакетов (зависит от `B`) запускается процесс расширения

#### **4. Процесс расширения (growing)**
Причины расширения:
1. Слишком много overflow-бакетов
2. Коэффициент нагрузки > 6.5 (среднее количество элементов на бакет)

Этапы расширения:
1. Выделяется новый массив бакетов в 2 раза больше
2. Начинается постепенное перемещение элементов (эвакуация)
3. При каждом обращении к map перемещается часть старых бакетов
4. После завершения oldbuckets освобождается

#### **5. Особенности производительности**
- Для маленьких map (<8 элементов) используется оптимизированная схема
- Порядок итерации специально рандомизирован
- Хеш-функция использует уникальное seed для каждой map

#### **6. Пример работы overflow-бакетов**
```go
m := make(map[int]int)
// Заполняем один бакет
for i := 0; i < 20; i++ {
    m[i*0x100] = i  // Все ключи попадут в один бакет
}
// Будет создана цепочка overflow-бакетов
```

**Ключевые моменты:**
- Overflow-бакеты - это механизм разрешения коллизий
- Они создаются только при реальной необходимости
- Система старается минимизировать их количество через своевременное расширение
