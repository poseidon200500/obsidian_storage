---
tags:
  - Шаблоны
  - Программирование
  - Теория_по_языку_Golang
Связанные темы:
---
## **Что такое кэш itab?**

Это глобальная хэш-таблица (map) внутри runtime Go, которая хранит ранее созданные структуры `itab` для быстрого повторного использования. Его главная цель — **избежать дорогостоящего повторного вычисления** `itab` для одной и той же пары (тип интерфейса, конкретный тип) каждое новое присваивание.

**Ключ кэша:** Пара `(interfacetype, _type)`, где:

- `interfacetype` — описание _интерфейса_ (например, `io.Writer`).
    
- `_type` — описание _конкретного типа_ (например, `*os.File`).
    

**Значение кэша:** Указатель на готовую, полностью инициализированную структуру `itab`.

---

## **Как работает кэш? (Жизненный цикл itab)**

Давайте проследим на примере `var w io.Writer = os.Stdout`:

### **1. Первое присваивание в программе (Кэш промах)**

1. **Поиск:** Runtime вычисляет ключ для пары (`interfacetype` для `io.Writer`, `_type` для `*os.File`) и ищет его в глобальном кэше.
    
2. **Промах:** Такой пары еще нет в кэше.
    
3. **Создание:** Runtime создает новую `itab` "на лету":
    
    - Выделяет память под структуру `itab`.
        
    - Заполняет поля `inter` и `_type`.
        
    - **Самое дорогое:** Проходит по всем методам, объявленным в интерфейсе `io.Writer`, и для каждого ищет соответствующую реализацию в таблице методов конкретного типа `*os.File`. Найденные указатели на методы записывает в массив `fun[0]`, `fun[1]` и т.д.
        
    - Копирует `hash` из `_type` в `itab.hash`.
        
4. **Кэширование:** Созданная `itab` добавляется в глобальную хэш-таблицу под вычисленным ключом.
    
5. **Связывание:** Указатель на эту новую `itab` записывается в поле `tab` переменной `w`, а указатель на `os.Stdout` — в поле `data`.
    

Этот процесс относительно медленный, но он происходит всего один раз для каждой уникальной пары тип-интерфейс.

### **2. Последующие присваивания (Кэш попадание)**

go

var w2 io.Writer = &myFile // myFile имеет тип *os.File
var w3 io.Writer = os.Stdout

1. **Поиск:** Runtime вычисляет тот же самый ключ для пары (`io.Writer`, `*os.File`).
    
2. **Попадание:** В кэше уже есть готовая `itab`.
    
3. **Мгновенное использование:** Runtime просто берет указатель на найденную `itab` и записывает его в поля `tab` переменных `w2` и `w3`. Дорогая операция поиска методов не повторяется.
    

Это очень быстрая операция, сравнимая с поиском в map.

---

## **Технические детали реализации**

Кэш реализован как **lock-free hash map** с использованием **atomic operations** для максимальной производительности в многопоточных средах. Это значит, что множество горутин могут одновременно читать из кэша и добавлять в него новые элементы без явных блокировок (mutex), что критически важно для скорости.

В исходном коде (`runtime/iface.go`) это выглядит примерно так:

go

// itabTableType - тип глобальной хэш-таблицы itab
type itabTableType struct {
    count    int                 // количество занятых entries
    entries  [][]*itab           // buckets для хранения itab (как в map)
}

// itabTable - сама глобальная переменная-кэш
var itabTable itabTableType

// Функция getitab - главная функция для получения itab
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
    // ... вычисляет хэш ключа ...
    // ... ищет в itabTable ...
    // если не находит - вызывает itabAdd для добавления
}

// itabAdd добавляет itab в глобальную таблицу
func itabAdd(m *itab) {
    // ... использует atomic операции (CAS) для безопасного добавления
    // в нужный bucket без полной блокировки всей таблицы
}

---

## **А что с assertion к интерфейсу?**

Когда вы делаете `val, ok := someInterface.(OtherInterface)`, runtime по сути выполняет ту же операцию: он пытается найти `itab` для пары (конкретный тип `someInterface`, интерфейс `OtherInterface`). Если находит — assertion успешен. Если нет — пытается её создать (и если не может — assertion fails).

## **Итог**

- **Да, это глобальный кэш.** Он один на всю программу.
    
- **Это не простой список, а хэш-таблица** с очень эффективным concurrent-доступом.
    
- **Его цель — экономия времени и памяти:** не создавать одинаковые `itab` repeatedly.
    
- **Благодаря ему** использование интерфейсов в Go становится очень дешевым после первого использования, что и позволяет активно применять их в коде без серьезных потерь в производительности.