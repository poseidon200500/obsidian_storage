---
tags:
  - Программирование
  - Теория_по_языку_Golang
  - Основы_языка_Golang
Связанные темы:
  - "[[Составные типы]]"
---
### **Мапы (словари) в Go**  


---

## **1. Основные понятия**  
Мапа (словарь) — коллекция пар **ключ-значение** с быстрым доступом по ключу.  

### **Базовый синтаксис**  
```go
// Инициализация
ages := map[string]int{
    "Алиса": 25,
    "Боб":   30,
}

// Чтение
age := ages["Алиса"] // 25

// Запись
ages["Чарли"] = 28

// Удаление
delete(ages, "Боб")
```

### **Нулевое значение**  
- Неинициализированная мапа равна `nil`  
- Попытка записи в `nil`-мапу вызывает панику:  
  ```go
  var m map[string]int
  m["key"] = 42 // panic: assignment to nil map
  ```

---

## **2. Ключевые особенности**  

### **a) Проверка существования ключа**  
Идиоматический способ:  
```go
if age, exists := ages["Дейв"]; exists {
    fmt.Println("Возраст Дейва:", age)
} else {
    fmt.Println("Дейв не найден")
}
```

### **b) Итерация**  
Порядок элементов **не гарантируется**:  
```go
for name, age := range ages {
    fmt.Printf("%s: %d лет\n", name, age)
}
```

### **c) Сравнение мап**  
Мапы можно сравнивать только с `nil`:  
```go
m1 := map[string]int{"a": 1}
m2 := map[string]int{"a": 1}
fmt.Println(m1 == m2) // Ошибка: maps can only be compared to nil
```

---
## 3. **Внутреннее устройство**
_Тип `map` в Go — это реализация хеш-таблицы, обеспечивающая быстрый доступ к данным по ключу (`O(1)` в среднем). Под капотом используется массив корзин (бакетов), где каждая корзина хранит связный список пар ключ-значение для разрешения коллизий. При увеличении нагрузки таблица автоматически расширяется._

**Особенности:**

- Неупорядоченность итерации    
- Отсутствие потокобезопасности
- Оптимизации для маленьких таблиц
    
#### **Мапы в Go 1.24+**

### **Ключевые особенности:**

- **Гибридная структура** (каталог + группы слотов)
- **Load factor 87.5%** (7/8 слотов в группе)
- **SIMD-оптимизации** для быстрого поиска
- **Плавный рост** (без резких скачков памяти)
- **Tombstone-маркеры** для эффективного удаления
    
**Отличия от старых мап:**

- На 15-35% быстрее поиск
- На 10-20% меньше памяти
- Нет эвакуации данных при росте
- Более предсказуемая производительность

**Недостатки:**

- Нет уменьшения размера при удалении
- Отдельные операции Put могут быть медленнее
- Требует современных CPU для SIMD
##### **См. подробнее:** 
- [[Мапы_внутреннее_устройство]]
- [[Внутреннее устройство map в Go 1.24+]]

---
## **3. Опасные моменты**  

### **a) Конкурентный доступ**  
Мапы **не потокобезопасны**:  
```go
// Опасный код!
go func() {
    m["key"] = 1 
}()
go func() {
    m["key"] = 2
}()
// Возможна паника: concurrent map write
```

**Решение:** Используйте `sync.Mutex` или `sync.Map`.

### **b) Изменение во время итерации**  
Приводит к неопределённому поведению:  
```go
for k := range m {
    delete(m, k) // Риск паники
}
```

### **c) Указатели в ключах**  
Ключи должны быть сравниваемыми:  
```go
m := make(map[*int]string) // Допустимо, но опасно
key := 10
m[&key] = "value"
```

---

## **4. Практические рекомендации**  

1. **Инициализация:**  
   ```go
   m := make(map[string]int, 100) // Предвыделение памяти
   ```

2. **Оптимизация:**  
   - Используйте простые типы для ключей (`int`, `string`)  
   - Избегайте вложенных мап (`map[string]map[string]int`)  

3. **Альтернативы:**  
   - `sync.Map` для конкурентного доступа  
   - Срезы структур, если порядок важен  

---

## **5. Производительность**  

### **a) Время доступа**  
- В среднем **O(1)** для простых ключей  
- Деградирует до **O(n)** при коллизиях  

### **b) Память**  
```go
m := make(map[int]int)
fmt.Println(unsafe.Sizeof(m)) // 8 байт (указатель)
```
Реальная память зависит от количества элементов.  

---


**Дополнительно:**  
- [Официальная документация](https://go.dev/ref/spec#Map_types)  
- [Effective Go: Мапы](https://go.dev/doc/effective_go#maps)  

---

Файл готов для сохранения в Obsidian. Подзаметки для углубления:  
- `maps/concurrency.md`  
- `maps/performance.md`  
- `maps/custom_keys.md`