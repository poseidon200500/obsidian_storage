---
tags:
  - Программирование
  - ВебОсновы
  - Протоколы
  - HTTP
Связанные темы:
---
Конечно! Давайте разберём эволюцию HTTP более подробно:

## 1. HTTP/1.0 (1996)

**Основные характеристики:**
```http
GET /index.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0
(пустая строка - конец заголовков)
```

**Проблемы:**
- **Новое соединение для каждого запроса**:
  ```go
  // Псевдокод - как это работало
  for each resource:
      connect to server
      send request
      receive response
      close connection
  ```
- **Большие накладные расходы** на установку TCP-соединения
- **Нет сжатия заголовков**
- **Блокирующие запросы** - пока не получим ответ, следующий не отправляем

## 2. HTTP/1.1 (1999) - КРИТИЧЕСКИЕ УЛУЧШЕНИЯ

### Persistent Connections
```http
GET /style.css HTTP/1.1
Host: example.com
Connection: keep-alive  # ← Новое!

GET /script.js HTTP/1.1
Host: example.com
Connection: keep-alive
# То же TCP-соединение!
```

**Что изменилось:**
- **Одно соединение для нескольких запросов**
- **Pipelining** (теоретически):
  ```http
  Request: GET /1 → GET /2 → GET /3
  Response: Resp/1 → Resp/2 → Resp/3  # В том же порядке!
  ```
- **Обязательный заголовок Host** - возможность виртуальных хостов
- **Чанкованная передача** для стриминга

**Проблемы оставались:**
- **Head-of-line blocking** - если первый запрос медленный, остальные ждут
- **Дублирование заголовков** в каждом запросе

## 3. HTTP/2 (2015) - РЕВОЛЮЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ

### Бинарный формат вместо текстового
```go
// HTTP/1.1 (текст)
"GET / HTTP/1.1\r\nHost: example.com\r\n\r\n"

// HTTP/2 (бинарные фреймы)
+-----------------------------------------------+
| Length (24) | Type (8) | Flags (8) | StreamID (31) |
|                   Payload                     |
+-----------------------------------------------+
```

### Мультиплексирование
```go
// В одном TCP-соединении:
Stream 1: HEADERS → DATA → DATA
Stream 2: HEADERS → DATA 
Stream 3: HEADERS → DATA → DATA → DATA
// Все потоки независимы!
```

**Ключевые фичи:**
- **Server Push** - сервер может отправить ресурсы до запроса:
  ```go
  // Клиент запрашивает index.html
  // Сервер сразу пушит: style.css, script.js, logo.png
  ```
- **Сжатие заголовков HPACK** - уменьшает дублирование
- **Приоритизация потоков** - важные ресурсы первыми

**Ограничения:**
- **TCP-level head-of-line blocking** - потеря одного пакета блокирует все потоки

## 4. HTTP/3 (2022) - UDP И КВАНТОВЫЙ СКАЧОК

### Переход с TCP на QUIC (UDP)
```go
// HTTP/2: TCP + TLS
[TCP Handshake] → [TLS Handshake] → [HTTP/2 Data]

// HTTP/3: QUIC (UDP)
[QUIC Handshake] → [HTTP/3 Data]  // Всё в одном раунде!
```

**Преимущества QUIC:**
- **Встроенная шифрация** - TLS 1.3 по умолчанию
- **Independent streams** - потеря пакета в одном потоке не влияет на другие:
  ```go
  Stream 1: Packet1 ✓, Packet2 ❌, Packet3 ✓  // Ждём Packet2
  Stream 2: Packet1 ✓, Packet2 ✓, Packet3 ✓  // Работает нормально!
  ```
- **Быстрое восстановление соединения** - Migration без переподключения

### Сравнение производительности:
```go
// Время установки соединения:
HTTP/1.1: 1-3 RTT (TCP + TLS)
HTTP/2:   1-3 RTT (TCP + TLS)  
HTTP/3:   0-1 RTT (QUIC)       // Иногда сразу данные!

// Устойчивость к потерям:
HTTP/2: Один потерянный пакет = все потоки ждут
HTTP/3: Потерянный пакет = блокирует только один поток
```

## Эволюция в цифрах:
- **HTTP/1.1**: 6 соединений на домен, ~100ms на запрос
- **HTTP/2**: 1 соединение, ~30ms на запрос (с мультиплексированием)
- **HTTP/3**: 1 соединение, ~10ms на запрос + устойчивость к потерям

Эта эволюция шла в направлении уменьшения задержек, увеличения параллелизма и улучшения пользовательского опыта.