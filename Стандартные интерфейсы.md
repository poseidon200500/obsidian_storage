---
tags:
  - Шаблоны
  - Программирование
  - Теория_по_языку_Golang
Связанные темы:
---
# **Стандартные интерфейсы в Go**

---

## **1. Важнейшие стандартные интерфейсы**

### **a) `io.Reader` и `io.Writer`**

#### **`io.Reader`**
```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```
**Контракт**: "Заполнить байтовый слайс данными и вернуть количество прочитанных байтов или ошибку."

**Реализации**: `os.File`, `strings.Reader`, `bytes.Buffer`, `http.Request.Body`

#### **`io.Writer`**
```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```
**Контракт**: "Записать байты из слайса и вернуть количество записанных байтов или ошибку."

**Реализации**: `os.File`, `bytes.Buffer`, `http.ResponseWriter`, `json.Encoder`

### **b) `error` - обработка ошибок**
```go
type error interface {
    Error() string
}
```
**Контракт**: "Вернуть человеко-читаемое описание ошибки."

### **c) `comparable` - типобезопасное сравнение**

#### **Что такое `comparable`?**
`comparable` — это встроенный интерфейс-ограничение для типов, которые поддерживают операции `==` и `!=`.

**Контракт**: "Тип может безопасно сравниваться операторами `==` и `!=`."

**Поддерживаемые типы**:
- Базовые типы: `int`, `string`, `bool`, `float64`
- Указатели: `*int`, `*string` 
- Каналы: `chan int`
- Интерфейсы: `interface{}`
- Структуры/массивы из сравнимых полей

**НЕ поддерживаются**: слайсы, мапы, функции, структуры с несравнимыми полями

#### **Практическое применение**:
```go
// Поиск элемента в слайсе
func Find[T comparable](slice []T, target T) int {
    for i, v := range slice {
        if v == target {
            return i
        }
    }
    return -1
}

// Удаление дубликатов
func Unique[T comparable](items []T) []T {
    seen := make(map[T]bool)
    result := make([]T, 0)
    for _, item := range items {
        if !seen[item] {
            seen[item] = true
            result = append(result, item)
        }
    }
    return result
}

// Типобезопасное множество
type Set[T comparable] map[T]struct{}

func (s Set[T]) Add(value T) {
    s[value] = struct{}{}
}

func (s Set[T]) Contains(value T) bool {
    _, exists := s[value]
    return exists
}
```

### **d) `fmt.Stringer` - строковое представление**
```go
type Stringer interface {
    String() string
}
```
**Контракт**: "Вернуть человеко-читаемое строковое представление объекта."

**Пример**:
```go
type User struct {
    Name  string
    Email string
}

func (u User) String() string {
    return fmt.Sprintf("%s <%s>", u.Name, u.Email)
}
```

### **e) `sort.Interface` - сортировка коллекций**
```go
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
```
**Контракт**: "Предоставить методы для определения размера, сравнения и перестановки элементов коллекции."

### **f) `context.Context` - управление временем жизни**
```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
```
**Контракт**: "Передавать deadlines, сигналы отмены и значения по цепочке вызовов."

### **g) `http.Handler` - обработка HTTP-запросов**
```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```
**Контракт**: "Обработать HTTP-запрос и сформировать ответ."

---

## **2. Практическое применение**

### **Универсальные функции с интерфейсами**
```go
// Работает с ЛЮБЫМ источником данных
func CountLines(r io.Reader) (int, error) {
    scanner := bufio.NewScanner(r)
    count := 0
    for scanner.Scan() {
        count++
    }
    return count, scanner.Err()
}

// Использование с разными источниками
lines1, _ := CountLines(strings.NewReader("hello\nworld"))  // строка
file, _ := os.Open("data.txt")
lines2, _ := CountLines(file)                              // файл
```

### **Дженерики с comparable**
```go
// Универсальная функция для любого сравнимого типа
func RemoveDuplicates[T comparable](slice []T) []T {
    seen := make(map[T]bool)
    result := []T{}
    for _, item := range slice {
        if !seen[item] {
            seen[item] = true
            result = append(result, item)
        }
    }
    return result
}

// Использование
numbers := []int{1, 2, 2, 3, 4, 4, 5}
uniqueNumbers := RemoveDuplicates(numbers) // [1, 2, 3, 4, 5]

names := []string{"Alice", "Bob", "Alice"}
uniqueNames := RemoveDuplicates(names) // ["Alice", "Bob"]
```

### **Тестирование с интерфейсами**
```go
func TestCountLines(t *testing.T) {
    tests := []struct {
        input    io.Reader
        expected int
    }{
        {strings.NewReader(""), 0},
        {strings.NewReader("one\ntwo\nthree"), 3},
    }
    
    for _, test := range tests {
        result, _ := CountLines(test.input)
        if result != test.expected {
            t.Errorf("Expected %d, got %d", test.expected, result)
        }
    }
}
```

---

## **3. Best Practices**

### **✔️ Принимайте интерфейсы, возвращайте структуры**
```go
// ХОРОШО
func NewProcessor(r io.Reader) *Processor {
    return &Processor{reader: r}
}
```

### **✔️ Используйте comparable для типобезопасных дженериков**
```go
// Безопасно работает с любым сравнимым типом
func Contains[T comparable](slice []T, value T) bool {
    for _, v := range slice {
        if v == value {
            return true
        }
    }
    return false
}
```

### **✔️ Определяйте интерфейсы на стороне потребителя**
```go
// В пакете, который ИСПОЛЬЗУЕТ функциональность
package myapp
type Storage interface {
    Save(data []byte) error
    Load(id string) ([]byte, error)
}
```

---

## **4. Опасные моменты**

### **Ограничения comparable**
```go
// НЕ СРАБОТАЕТ - слайсы не comparable
func CompareSlices[T comparable](a, b []T) bool {
    return a == b // Ошибка компиляции!
}

// РЕШЕНИЕ - использовать reflect.DeepEqual
func CompareSlices[T any](a, b []T) bool {
    return reflect.DeepEqual(a, b)
}
```

### **Слишком абстрактные интерфейсы**
```go
// ПЛОХО
type ThingDoer interface {
    DoThing()
}

// ЛУЧШЕ
type DataProcessor interface {
    Process(data []byte) ([]byte, error)
}
```

---

**Когда использовать стандартные интерфейсы?**

✔️ Для создания переиспользуемых компонентов  
✔️ При работе с вводом-выводом  
✔️ Для улучшения тестируемости кода  
✔️ Используйте `comparable` для типобезопасных операций сравнения в дженериках  

❌ Не создавайте собственные интерфейсы, дублирующие стандартные  
❌ Помните об ограничениях `comparable`