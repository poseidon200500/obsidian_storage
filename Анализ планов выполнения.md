---
tags:
  - Программирование
  - SQL
  - Основы_языка_SQL
Связанные_темы: "[[Оптимизация запросов]]"
---
# Анализ планов выполнения в PostgreSQL

## 1. Команды EXPLAIN и EXPLAIN ANALYZE

### Базовое использование EXPLAIN

**EXPLAIN** - показывает предполагаемый план выполнения без реального выполнения запроса:

```sql
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';
```

**Результат:**
```
QUERY PLAN
Index Scan using idx_users_email on users  (cost=0.14..8.16 rows=1 width=64)
  Index Cond: (email = 'test@example.com'::text)
```

**EXPLAIN ANALYZE** - выполняет запрос и показывает фактическую статистику:

```sql
EXPLAIN ANALYZE 
SELECT * FROM orders WHERE total_amount > 1000;
```

**Результат:**
```
QUERY PLAN
Seq Scan on orders  (cost=0.00..1254.32 rows=24581 width=48) (actual time=0.012..25.341 rows=23045 loops=1)
  Filter: (total_amount > 1000)
  Rows Removed by Filter: 15432
Planning Time: 0.125 ms
Execution Time: 27.891 ms
```

### Расширенные опции EXPLAIN

**Комprehensive анализ с различными опциями:**
```sql
EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON, TIMING, VERBOSE)
SELECT u.name, o.order_date, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.created_at > '2023-01-01'
ORDER BY o.order_date DESC
LIMIT 100;
```

**Доступные форматы вывода:**
- `TEXT` - текстовый формат (по умолчанию)
- `JSON` - JSON структура для программного анализа
- `XML` - XML представление
- `YAML` - YAML формат

## 2. Чтение и интерпретация планов запросов

### Структура узла плана выполнения

**Базовая структура стоимости:**
```
(cost=0.00..1254.32 rows=24581 width=48)
```
- **cost=0.00..1254.32** - диапазон стоимости (начало..конец)
- **rows=24581** - ожидаемое количество строк
- **width=48** - средний размер строки в байтах

**Фактическая статистика:**
```
(actual time=0.012..25.341 rows=23045 loops=1)
```
- **actual time=0.012..25.341** - время выполнения (начало..конец в ms)
- **rows=23045** - фактическое количество строк
- **loops=1** - количество выполнений узла

### Типы операций доступа к данным

**Seq Scan (Последовательное сканирование):**
```sql
EXPLAIN ANALYZE SELECT * FROM large_table WHERE status = 'active';
```
```
Seq Scan on large_table  (cost=0.00..12540.50 rows=50000 width=100)
  Filter: (status = 'active'::text)
  Rows Removed by Filter: 950000
```
*Используется когда: нет подходящего индекса или нужно прочитать большую часть таблицы*

**Index Scan (Сканирование по индексу):**
```sql
EXPLAIN ANALYZE SELECT * FROM users WHERE id = 12345;
```
```
Index Scan using users_pkey on users  (cost=0.29..8.31 rows=1 width=64)
  Index Cond: (id = 12345)
```
*Используется когда: точечный поиск по индексированному полю*

**Index Only Scan (Только индексное сканирование):**
```sql
EXPLAIN ANALYZE SELECT id, email FROM users WHERE email LIKE 'a%';
```
```
Index Only Scan using idx_users_email on users  (cost=0.14..12.45 rows=250 width=40)
  Index Cond: ((email >= 'a'::text) AND (email < 'b'::text))
  Heap Fetches: 0
```
*Используется когда: все нужные колонки есть в индексе*

**Bitmap Heap Scan:**
```sql
EXPLAIN ANALYZE SELECT * FROM orders 
WHERE user_id BETWEEN 1000 AND 2000 AND status = 'completed';
```
```
Bitmap Heap Scan on orders  (cost=125.45..890.23 rows=1500 width=48)
  Recheck Cond: ((user_id >= 1000) AND (user_id <= 2000) AND (status = 'completed'::text))
  ->  Bitmap Index Scan on idx_orders_user_status  (cost=0.00..125.08 rows=1500 width=0)
        Index Cond: ((user_id >= 1000) AND (user_id <= 2000) AND (status = 'completed'::text))
```
*Используется когда: множественные условия по индексу*

## 3. Анализ стоимости операций (cost)

### Компоненты стоимости

**Cost = (seq_page_cost × pages) + (cpu_tuple_cost × tuples) + (cpu_operator_cost × operations)**

**Типичные значения стоимости:**
- **seq_page_cost** = 1.0 (стоимость чтения последовательной страницы)
- **random_page_cost** = 4.0 (стоимость чтения случайной страницы)
- **cpu_tuple_cost** = 0.01 (стоимость обработки строки)
- **cpu_index_tuple_cost** = 0.005 (стоимость обработки индексной записи)

### Анализ эффективности по стоимости

**Высокая начальная стоимость** - может указывать на дорогие подготовительные операции:
```
Nested Loop  (cost=1000.45..1250.89 rows=10 width=64)
```

**Большой разброс стоимости** - плохая оценка количества строк:
```
Seq Scan  (cost=0.00..15420.50 rows=1 width=100) (actual time=120.45..120.46 rows=50000 loops=1)
```

**Оптимальный план** - низкая стоимость и точная оценка:
```
Index Scan  (cost=0.29..8.31 rows=1 width=64) (actual time=0.012..0.013 rows=1 loops=1)
```

## 4. Статистика ввода/вывода (BUFFERS)

### Использование опции BUFFERS

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM large_table WHERE category_id IN (1, 2, 3);
```

**Результат с буферами:**
```
Seq Scan on large_table  (cost=0.00..15420.50 rows=150000 width=100)
                         (actual time=0.015..245.123 rows=148923 loops=1)
  Filter: (category_id = ANY ('{1,2,3}'::integer[]))
  Rows Removed by Filter: 851077
  Buffers: shared hit=25432 read=12540
Planning:
  Buffers: shared hit=15
Planning Time: 0.245 ms
Execution Time: 248.891 ms
```

### Интерпретация статистики буферов

- **shared hit** - страницы из shared buffers (кэш)
- **shared read** - страницы с диска
- **temp read/written** - временные файлы
- **local hit/read** - локальные буферы

**Анализ эффективности кэширования:**
```sql
-- Коэффициент попадания в кэш
SELECT 25432.0 / (25432 + 12540) as cache_hit_ratio; -- ≈67%
```

## 5. Выявление узких мест производительности

### Типичные проблемы и решения

**1. Полное сканирование больших таблиц:**
```sql
-- ПРОБЛЕМА:
EXPLAIN ANALYZE SELECT * FROM logs WHERE level = 'ERROR';
-- Seq Scan on logs, время: 1250ms

-- РЕШЕНИЕ:
CREATE INDEX idx_logs_level ON logs(level) WHERE level = 'ERROR';
-- Index Scan using idx_logs_level, время: 45ms
```

**2. Неэффективные JOIN операции:**
```sql
-- ПРОБЛЕМА:
EXPLAIN ANALYZE 
SELECT u.*, o.* FROM users u 
JOIN orders o ON u.id = o.user_id;
-- Nested Loop с большим количеством циклов

-- РЕШЕНИЕ:
SET enable_nestloop = off; -- Принудительно отключить nested loop
-- или добавить индексы на join-колонки
```

**3. Плохие оценки количества строк:**
```sql
-- ПРОБЛЕМА:
EXPLAIN ANALYZE SELECT * FROM products WHERE price BETWEEN 100 AND 200;
-- Ожидалось: rows=1000, Фактически: rows=15000

-- РЕШЕНИЕ:
ANALYZE products; -- Обновить статистику
-- или увеличить statistics target для колонки
ALTER TABLE products ALTER COLUMN price SET STATISTICS 1000;
```

### Практический workflow анализа

**Шаг 1: Базовый анализ**
```sql
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM your_slow_query;
```

**Шаг 2: Выявление проблемных узлов**
- Ищем узлы с наибольшим actual time
- Проверяем разницу между estimated и actual rows
- Анализируем количество buffers read с диска

**Шаг 3: Поиск решений**
- Добавление недостающих индексов
- Переписывание запроса
- Обновление статистики
- Изменение конфигурации

**Шаг 4: Валидация улучшений**
```sql
-- Сравнение до и после
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM optimized_query;
```

### Полезные системные представления

```sql
-- Поиск медленных запросов
SELECT query, calls, total_time, mean_time, rows
FROM pg_stat_statements 
ORDER BY mean_time DESC 
LIMIT 10;

-- Статистика по таблицам
SELECT schemaname, tablename, seq_scan, seq_tup_read,
       idx_scan, idx_tup_fetch
FROM pg_stat_user_tables 
WHERE seq_scan > 1000;
```

Этот подход позволяет систематически анализировать и оптимизировать производительность запросов в PostgreSQL, выявляя реальные узкие места и применяя целенаправленные решения.